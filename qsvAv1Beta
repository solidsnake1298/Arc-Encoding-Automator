#!/bin/bash

###########################
# Assumes jellyfin-ffmpeg is installed and symlinked in /usr/bin.
# Most functions may work with vanilla ffmpeg, but may require additional Intel drivers.
# Removing Dolby Vision function requires jellyfin-ffmpeg 7.0.2-4 and newer.
# Must have jq and bc installed.
# User running this script must be in render group.  Requires user logout if added to group.
##########################

# Variable initialization.  Work-in-progress initialization and cleanup.
INPUTFILE=""
CHAPTERSEPISODE=
CHAPSELECT=
ANIME=0
KOREAN=0
CHINESE=0
RESCALE=0
FILTERS=""
CHAPTERFILES=""
FINALAUDIO=""
SELECTEDAUDIO=""
SELECTEDSUBS=""
SUBCOMMAND=""
ATTACHMENTCOMMAND=""
NOHWADECODE=0
SCRATCHDIR=""
ENGLISHSELECTION=0
AUDIOCONVERSION=0
EMPTYCHAPTERPROBE=""

# Reads input paramamters
while getopts i:c:a:k:r:s:h:w:e:o:m: option; do
        case ${option} in
                i) INPUTFILE=${OPTARG};;
                c) CHAPTERSEPISODE=${OPTARG};;
                a) ANIME=${OPTARG};;
                k) KOREAN=${OPTARG};;
		m) CHINESE=${OPTARG};;
                r) RESCALE=${OPTARG};;
		s) CHAPSELECT=${OPTARG};;
		h) NOHWADECODE=${OPTARG};;
		w) SCRATCHDIR=${OPTARG};;
		e) ENGLISHSELECTION=${OPTARG};;
		o) AUDIOCONVERSION=${OPTARG};;
               \?) echo "Invalid option"
                   exit;;
        esac
done

# Checks for required input file name
if [ -z "${INPUTFILE}" ]; then
        echo "No input file was provided."
        exit 1
fi
# If no SCRATCHDIR provided, use current dir
if [ -z "${SCRATCHDIR}" ]; then
	SCRATCHDIR="."
fi

WIP=${SCRATCHDIR}/WIP
mkdir -p ${WIP}

# Uses Intel QSV to encode the original AV1.  Maps the audio tracks for the selected languages, and converts to them to OPUS.
# Includes attachments if present.  If splitting out episodes from a MKV that came off the disc as a single file, it will loop through for each episode.
# If using jellyfin-ffmpeg7.0.2-4 and newer, DV 7.6 and 8 will automatically be stripped.
av1Encode () {
	local audioCommand=$(audioMapping)
	local subCommand=$(subMapping)

while read file; do
	echo "Converting to AV1 ${INPUTFILE}"
	inputFile="${file}"
        if [ -z ${CHAPTERSEPISODE} ] && [ -z ${STARTCHAP} ] && [ -z ${ENDCHAP} ]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
	elif [[ "${EMPTYCHAPTERPROBE}" == "true" ]]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
        else
		inputFile=$(echo ${WIP}/${inputFile})
                startChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $1}')
                endChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $2}')
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-${startChapter}-${endChapter}.mkv/g")
        fi
        ffmpeg \
		-y \
                -init_hw_device vaapi=va:,driver=iHD,kernel_driver=i915 \
		-hide_banner \
		-stats \
		-fflags +genpts+igndts \
		-v error \
                -init_hw_device qsv=qs@va \
                -filter_hw_device qs \
                ${decodeAccel} \
                -hwaccel_output_format qsv \
		-extra_hw_frames 40 \
                -i "${inputFile}" \
                -map_chapters 0 \
		-map 0:v:0 \
                -c:v av1_qsv \
                -q:v 22 \
                -look_ahead_depth 40 \
                -preset veryslow \
                -vf vpp_qsv="${FILTERS}" \
		${audioCommand} \
		${subCommand} \
		-fps_mode passthrough \
		-disposition:s 0 \
		-low_delay_brc 1 \
		-extbrc 1 \
		-adaptive_i 1 \
		-adaptive_b 1 \
		-b_strategy 1 \
		-bf 39 \
		-max_muxing_queue_size 2048 \
		-max_interleave_delta 0 \
		-avoid_negative_ts disabled \
                "${outputFile}" < /dev/null
done <<< "${CHAPTERFILES}"

# Rechecks chapters, but only if present in input file
# Duration can shift slightly during encoding, which causes the last chapter
# to, potentially, end after the duration.
if [ ${BADCHAPTER} -ne 0 ]; then
        echo "Rechecking output file chapters"
        BADCHAPTER=$(checkChapters "${outputFile}")
        if [ ${BADCHAPTER} -gt 1 ]; then
                newOutputFile=$(echo ${outputFile} | sed 's/.mkv/-chapterFix.mkv/g')
                echo "Output file has bad chapters.  Duration can change slightly during encoding, triggering this issue."
                repairChapters "${outputFile}" "${newOutputFile}"
                mv "${newOutputFile}" "${outputFile}"
        else
                echo "All chapters valid in output file"
        fi
fi
}

# Only remuxes tracks with selected languages
remuxOnly () {
        local audioCommand=$(audioMapping)
        local subCommand=$(subMapping)
                
while read file; do
	echo "Remuxing ${INPUTFILE}"
        inputFile="${file}"
        if [ -z ${CHAPTERSEPISODE} ] && [ -z ${STARTCHAP} ] && [ -z ${ENDCHAP} ]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
        elif [[ "${EMPTYCHAPTERPROBE}" == "true" ]]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
        else
                inputFile=$(echo ${WIP}/${inputFile})
                startChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $1}')
                endChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $2}')
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-${startChapter}-${endChapter}.mkv/g")
        fi
        ffmpeg \
                -y \
                -hide_banner \
                -stats \
                -fflags +genpts+igndts \
                -v error \
                -i "${inputFile}" \
                -map_chapters 0 \
                -map 0:v:0 \
                -c:v copy \
                ${audioCommand} \
                ${subCommand} \
                -disposition:s 0 \
                -max_muxing_queue_size 2048 \
                -max_interleave_delta 0 \
                -avoid_negative_ts disabled \
                "${outputFile}" < /dev/null
done <<< "${CHAPTERFILES}"

# Rechecks chapters, but only if present in input file
# Duration can shift slightly during encoding, which causes the last chapter
# to, potentially, end after the duration.
if [ ${BADCHAPTER} -ne 0 ]; then
        echo "Rechecking output file chapters"
        BADCHAPTER=$(checkChapters "${outputFile}")
        if [ ${BADCHAPTER} -gt 1 ]; then
                newOutputFile=$(echo ${outputFile} | sed 's/.mkv/-chapterFix.mkv/g')
                echo "Output file has bad chapters.  Duration can change slightly during encoding, triggering this issue."
                repairChapters "${outputFile}" "${newOutputFile}"
                mv "${newOutputFile}" "${outputFile}"
        else
                echo "All chapters valid in output file"
        fi
fi
}

audioConversionOnly () {
        local audioCommand=$(audioMapping)
        local subCommand=$(subMapping)
                
while read file; do
	echo "Converting audio only for ${INPUTFILE}"
        inputFile="${file}"
        if [ -z ${CHAPTERSEPISODE} ] && [ -z ${STARTCHAP} ] && [ -z ${ENDCHAP} ]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
        elif [[ "${EMPTYCHAPTERPROBE}" == "true" ]]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
        else
                inputFile=$(echo ${WIP}/${inputFile})
                startChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $1}')
                endChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $2}')
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-${startChapter}-${endChapter}.mkv/g")
        fi
        ffmpeg \
                -y \
                -hide_banner \
                -stats \
                -fflags +genpts+igndts \
                -v error \
                -i "${inputFile}" \
                -map_chapters 0 \
                -map 0:v:0 \
                -c:v copy \
                ${audioCommand} \
                ${subCommand} \
                -disposition:s 0 \
                -max_muxing_queue_size 2048 \
                -max_interleave_delta 0 \
                -avoid_negative_ts disabled \
                "${outputFile}" < /dev/null
done <<< "${CHAPTERFILES}"

# Rechecks chapters, but only if present in input file
# Duration can shift slightly during encoding, which causes the last chapter
# to, potentially, end after the duration.
if [ ${BADCHAPTER} -ne 0 ]; then
        echo "Rechecking output file chapters"
        BADCHAPTER=$(checkChapters "${outputFile}")
        if [ ${BADCHAPTER} -gt 1 ]; then
                newOutputFile=$(echo ${outputFile} | sed 's/.mkv/-chapterFix.mkv/g')
                echo "Output file has bad chapters.  Duration can change slightly during encoding, triggering this issue."
                repairChapters "${outputFile}" "${newOutputFile}"
                mv "${newOutputFile}" "${outputFile}"
        else
                echo "All chapters valid in output file"
        fi
fi
}

# Selects English and Japanese audio tracks for processing.  If lossless tracks are present for a language, lossy tracks for that language are ignored.
audioMapping () {
	if [ ${ANIME} -eq 1 ]; then
		# checks if audio.json is empty due to untagged streams
		# if lossless tracks are present, ignore lossy tracks
		if [ "${EMPTYAUDIOJSON}" = 'true' ]; then
			echo "Selected audio returned no results.  Selecting all audio tracks." > /dev/tty
			FINALAUDIO=$(jq -r '[.streams.[]] | .[] | .index' <<< "${AUDIOFFPROBE}")
			SELECTEDAUDIO=$(jq -r '[.streams.[]]' <<< "${AUDIOFFPROBE}")
		else
			lossless=$(jq -r '.[] | select(.tags.language == ("eng"))'  <<< "${SELECTEDAUDIO}" | egrep -i "dts-hd ma|truehd|flac" | grep -v "title" | head -1)
			if [ ! -z "${lossless}" ]; then
				echo "Finding lossless English audio tracks, if any" > /dev/tty
				codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
				if [ ! -z "`echo ${codec} | grep -i dts`" ]; then
					FINALAUDIO=$(jq -r '.[] | select((.profile == ("DTS-HD MA") or .profile == ("DTS-HD MA + DTS:X")) and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found DTS HD Master Audio track.  Ignoring other English tracks" > /dev/tty
				elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then
					FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("truehd") and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found Dolby TrueHD audio track.  Ignoring other English tracks" > /dev/tty
				elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then
					FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("flac") and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found FLAC audio track.  Ignoring other English tracks" > /dev/tty
				fi
			else
				FINALAUDIO=$(jq -r '.[] | select(.tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
				echo "No lossless English tracks found" > /dev/tty
			fi
                        lossless=$(jq -r '.[] | select(.tags.language == ("jpn"))' <<< "${SELECTEDAUDIO}" | egrep -i "dts-hd ma|truehd|flac" | grep -v "title" | head -1)
                        if [ ! -z "${lossless}" ]; then
				echo "Finding lossless Japanese audio tracks, if any" > /dev/tty
                                codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
                                if [ ! -z "`echo ${codec} | grep -i dts`" ]; then
					FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select((.profile == ("DTS-HD MA") or .profile == ("DTS-HD MA + DTS:X")) and .tags.language == ("jpn")) | .index' <<< "${SELECTEDAUDIO}")"
					echo "Found DTS HD Master Audio track.  Ignoring other Japanese tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then
					FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.codec_name == ("truehd") and .tags.language == ("jpn")) | .index' <<< "${SELECTEDAUDIO}")"
					echo "Found Dolby TrueHD audio track.  Ignoring other Japanese tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then
					FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.codec_name == ("flac") and .tags.language == ("jpn")) | .index' <<< "${SELECTEDAUDIO}")"
					echo "Found FLAC audio track.  Ignoring other Japanese tracks" > /dev/tty
                                fi
                        else
				FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.tags.language == ("jpn")) | .index' <<< "${SELECTEDAUDIO}")"
				echo "No lossless Japanese tracks found" > /dev/tty
                        fi
		fi
	elif [ ${KOREAN} -eq 1 ]; then
                if [ "${EMPTYAUDIOJSON}" = 'true' ]; then
                        echo "Selected audio returned no results.  Selecting all audio tracks." > /dev/tty
                        FINALAUDIO=$(jq -r '[.streams.[]] | .[] | .index' <<< "${AUDIOFFPROBE}")
			SELECTEDAUDIO=$(jq -r '[.streams.[]]' <<< "${AUDIOFFPROBE}")
                else
                        lossless=$(jq -r '.[] | select(.tags.language == ("eng"))'  <<< "${SELECTEDAUDIO}" | egrep -i "dts-hd ma|truehd|flac" | grep -v "title" | head -1)
                        if [ ! -z "${lossless}" ]; then
                                echo "Finding lossless English audio tracks, if any" > /dev/tty
                                codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
                                if [ ! -z "`echo ${codec} | grep -i dts`" ]; then
                                        FINALAUDIO=$(jq -r '.[] | select((.profile == ("DTS-HD MA") or .profile == ("DTS-HD MA + DTS:X")) and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                        echo "Found DTS HD Master Audio track.  Ignoring other English tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then
                                        FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("truehd") and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                        echo "Found Dolby TrueHD audio track.  Ignoring other English tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then
                                        FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("flac") and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                        echo "Found FLAC audio track.  Ignoring other English tracks" > /dev/tty
                                fi
                        else
                                FINALAUDIO=$(jq -r '.[] | select(.tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                echo "No lossless English tracks found" > /dev/tty
                        fi
                        lossless=$(jq -r '.[] | select(.tags.language == ("kor"))' <<< "${SELECTEDAUDIO}" | egrep -i "dts-hd ma|truehd|flac" | grep -v "title" | head -1)
                        if [ ! -z "${lossless}" ]; then
				echo "Finding lossless Korean audio tracks, if any" > /dev/tty
                                codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
                                if [ ! -z "`echo ${codec} | grep -i dts`" ]; then
                                        FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select((.profile == ("DTS-HD MA") or .profile == ("DTS-HD MA + DTS:X")) and .tags.language == ("kor")) | .index' <<< "${SELECTEDAUDIO}")"
					echo "Found DTS HD Master Audio track.  Ignoring other Korean tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then
                                        FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.codec_name == ("truehd") and .tags.language == ("kor")) | .index' <<< "${SELECTEDAUDIO}")"
					echo "Found Dolby TrueHD audio track.  Ignoring other Korean tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then
                                        FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.codec_name == ("flac") and .tags.language == ("kor")) | .index' <<< "${SELECTEDAUDIO}")"
					echo "Found FLAC audio track.  Ignoring other Korean tracks" > /dev/tty
                                fi
                        else
                                FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.tags.language == ("kor")) | .index' <<< "${SELECTEDAUDIO}")"
				echo "No lossless Korean tracks found" > /dev/tty
                        fi
		fi
        elif [ ${CHINESE} -eq 1 ]; then
                if [ "${EMPTYAUDIOJSON}" = 'true' ]; then
                        echo "Selected audio returned no results.  Selecting all audio tracks." > /dev/tty
                        FINALAUDIO=$(jq -r '[.streams.[]] | .[] | .index' <<< "${AUDIOFFPROBE}")
                        SELECTEDAUDIO=$(jq -r '[.streams.[]]' <<< "${AUDIOFFPROBE}")
                else    
                        lossless=$(jq -r '.[] | select(.tags.language == ("eng"))'  <<< "${SELECTEDAUDIO}" | egrep -i "dts-hd ma|truehd|flac" | grep -v "title" | head -1)
                        if [ ! -z "${lossless}" ]; then
                                echo "Finding lossless English audio tracks, if any" > /dev/tty
                                codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
                                if [ ! -z "`echo ${codec} | grep -i dts`" ]; then
                                        FINALAUDIO=$(jq -r '.[] | select((.profile == ("DTS-HD MA") or .profile == ("DTS-HD MA + DTS:X")) and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                        echo "Found DTS HD Master Audio track.  Ignoring other English tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then
                                        FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("truehd") and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                        echo "Found Dolby TrueHD audio track.  Ignoring other English tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then
                                        FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("flac") and .tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                        echo "Found FLAC audio track.  Ignoring other English tracks" > /dev/tty
                                fi
                        else
                                FINALAUDIO=$(jq -r '.[] | select(.tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
                                echo "No lossless English tracks found" > /dev/tty
                        fi
			lossless=$(jq -r '.[] | select(.tags.language == ("chi") or .tags.language == ("zho"))' <<< "${SELECTEDAUDIO}" | egrep -i "dts-hd ma|truehd|flac" | grep -v "title" | head -1)
                        if [ ! -z "${lossless}" ]; then
                                echo "Finding lossless Chinese audio tracks, if any" > /dev/tty
                                codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
                                if [ ! -z "`echo ${codec} | grep -i dts`" ]; then
					FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select((.profile == ("DTS-HD MA") or .profile == ("DTS-HD MA + DTS:X")) and .tags.language == ("chi") or .tags.language == ("zho")) | .index' <<< "${SELECTEDAUDIO}")"
                                        echo "Found DTS HD Master Audio track.  Ignoring other Korean tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then
					FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.codec_name == ("truehd") and .tags.language == ("chi") or .tags.language == ("zho")) | .index' <<< "${SELECTEDAUDIO}")"
                                        echo "Found Dolby TrueHD audio track.  Ignoring other Korean tracks" > /dev/tty
                                elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then
					FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.codec_name == ("flac") and .tags.language == ("chi") or .tags.language == ("zho")) | .index' <<< "${SELECTEDAUDIO}")"
                                        echo "Found FLAC audio track.  Ignoring other Korean tracks" > /dev/tty
                                fi
                        else
				FINALAUDIO="${FINALAUDIO} $(jq -r '.[] | select(.tags.language == ("chi") or .tags.language == ("zho")) | .index' <<< "${SELECTEDAUDIO}")"
                                echo "No lossless Chinese tracks found" > /dev/tty
                        fi
                fi
        else
                # checks if audio.json is empty due to untagged streams
                if [ "${EMPTYAUDIOJSON}" = 'true' ]; then
                        echo "Selected audio returned no results.  Selecting all audio tracks." > /dev/tty
			FINALAUDIO=$(jq -r '[.streams[]] | .[] | .index' <<< "${AUDIOFFPROBE}")
			SELECTEDAUDIO=$(jq -r '[.streams.[]]' <<< "${AUDIOFFPROBE}")
		else
                	lossless=$(egrep -i "dts-hd ma|truehd|flac" <<< "${SELECTEDAUDIO}" | grep -v "title" | head -1)
	                if [ ! -z "${lossless}" ]; then
				echo "Finding lossless English audio tracks, if any" > /dev/tty
	                        codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
	                        if [ ! -z "`echo ${codec} | grep -i dts`" ]; then
					FINALAUDIO=$(jq -r '.[] | select(.profile == ("DTS-HD MA") or .profile == ("DTS-HD MA + DTS:X")) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found DTS HD Master Audio track.  Ignoring other English tracks" > /dev/tty
	                        elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then
					FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("truehd")) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found Dolby TrueHD audio track.  Ignoring other English tracks" > /dev/tty
	                        elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then
					FINALAUDIO=$(jq -r '.[] | select(.codec_name == ("flac")) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found FLAC audio track.  Ignoring other English tracks" > /dev/tty
	                        fi
	                else
				FINALAUDIO=$(jq -r '.[] | select(.tags.language == ("eng")) | .index' <<< "${SELECTEDAUDIO}")
				echo "No lossless English tracks found" > /dev/tty
	                fi        
		fi
	fi
	
	firstTrack=$(jq -r '.streams[0] | .index' <<< "${AUDIOFFPROBE}" | bc)
	skipConversion=$(jq -r '.[] | select(.codec_name == ("aac") or .codec_name == ("mp3") or .codec_name == ("flac") or .codec_name ==("opus") or .codec_name ==("vorbis")) | .index' <<< "${SELECTEDAUDIO}")
	audioLoop=""
	trackNumber=0
	audioCommand=$(for rawIndex in ${FINALAUDIO}; do
		contains ${rawIndex} ${skipConversion}
		compatCodec=$(echo $? | bc)
		index=$(awk "BEGIN {print ${rawIndex} - ${firstTrack}}" | bc)
		if [ ${compatCodec} -eq 0 ] || [ ${ENGLISHSELECTION} -eq 1 ]; then
	                audioLoop="-map 0:a:${index} -c:a:${trackNumber} copy"
			echo "Audio codec for track ${trackNumber} is already FOSS or widely compatible." > /dev/tty
			((++trackNumber))
			echo ${audioLoop}
		else
			audioLoop="-map 0:a:${index} -c:a:${trackNumber} libopus -vbr on -compression_level 10 -application audio"
			channels=$(jq --arg l ${index} '.streams[$l|fromjson].channels' <<< "${AUDIOFFPROBE}")
			echo "Track ${trackNumber} will be converted to OPUS" > /dev/tty
			if [ ${channels} -gt 2 -a ${channels} -lt 6 ]; then
				audioLoop="-mapping_family 1 -ac ${channels}"
			fi
			((++trackNumber))
			echo ${audioLoop}
		fi
	done)
	echo "${audioCommand}"
}

set +e
contains() {
	local e match="${1}"
	shift
	for e; do
		[[ "${e}" == "${match}" ]] && return 0
	done
	return 1
}

# Selects and maps English and Japanese subtitle tracks.
subMapping () {
	firstTrack=$(jq -r '.streams[0] | .index' <<< "${SUBFFPROBE}" | bc)
	noMovText=$(jq '[.streams[] | select(.codec_name == ("mov_text"))]' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
	# Checks for no subtitle track.  Common for older fansubs with burned in subtitles.
	if [ "${EMPTYSUBJSON}" = 'true' ] || [ "${SELECTEDSUBS}" == "[]" ]; then
		echo "No subtitles detected" > /dev/tty
		SUBCOMMAND="-sn"
	elif [ "${noMovText}" = 'false' ]; then
		echo "Converting mov_text to SRT" > /dev/tty
		trackNumber=0
		SUBCOMMAND=$(while read rawIndex; do
			index=$(awk "BEGIN {print ${rawIndex} - ${firstTrack}}" | bc)
			noMovText=$(jq --arg l ${index} '.streams[$l|fromjson] | select(.codec_name == ("mov_text"))' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
			if [ "${noMovText}" = 'false' ]; then
				subLoop="-map 0:s:${index} -c:s:${trackNumber} srt"
				((++trackNumber))
				echo ${subLoop}
			else
				subLoop="-map 0:s:${index} -c:s:${trackNumber} copy"
				((++trackNumber))
				echo ${subLoop}
			fi
		done <<< "$(jq '.[].index' <<< "${SELECTEDSUBS}")")
	else
	# If audio language tags are not present, it is safe to assume subtitle language tags aren't either
		SUBCOMMAND="-c:s copy"
		echo "Mapping subtitle tracks" > /dev/tty
		while read rawIndex; do
			index=$(awk "BEGIN {print ${rawIndex} - ${firstTrack}}" | bc)
			SUBCOMMAND="${SUBCOMMAND} -map 0:s:${index}"
		done <<< "$(jq '.[].index' <<< "${SELECTEDSUBS}")"
	fi
	
	index=0
	fonts=""
	firstAttachmentTrack=$(jq -r '.streams[0] | .index' <<< "${ATTACHMENTFFPROBE}" | bc)
        # Checks for attachments.  Only expected when using ASS subtitles.
        if [ "${EMPTYATTACHMENTJSON}" = 'true' ]; then
		echo "Including all attachments, if any" > /dev/tty
        	ATTACHMENTCOMMAND="-map 0:t?"
	elif [ "${SUBCOMMAND}" = '-sn' ]; then
		echo "No subtitle tracks, dropping all attachments" > /dev/tty
		ATTACHMENTCOMMAND=""
        else
		echo "Extracting fonts used by selected ASS tracks" > /dev/tty
		# When there are fonts, pulls in ASS sub style lines from the tracks selected
		while read subIndex ; do
			index=$(awk "BEGIN {print ${subIndex} - ${firstTrack}}" | bc)
			isSubASS=$(jq --arg l ${index} '.streams[$l|fromjson] | select(.codec_name == ("ass"))' <<< ${SUBFFPROBE} | jq -e '. | length != 0')
			if [ "${isSubASS}" = 'true' ]; then
				newFonts=$(ffmpeg -v error -stats -i "${remuxOutputFile}" -vn -an -map 0:s:${index} -f ass - | egrep "^Style:" | awk -F ':' '{print $2}' | awk -F ',' '{print $2}')
				fonts+="${newFonts}"
			fi
		done <<< "$(jq '.[].index' <<< "${SELECTEDSUBS}")"
		echo "Dumping attachments and dropping unused fonts" > /dev/tty
                uniqueFonts=$(echo -e "${fonts}" | sort | uniq)
                ATTACHMENTCOMMAND=$(while read attachmentIndex ; do
                        index=$(awk "BEGIN {print ${attachmentIndex} - ${firstAttachmentTrack}}" | bc)
                        fontFileName=$(jq --arg l ${index} '.streams[$l|fromjson].tags.filename' <<< ${ATTACHMENTFFPROBE})
                        ffmpeg -v fatal -dump_attachment:t:${index} "${fontFileName}" -i "${INPUTFILE}"
                        fontFullName=$(fc-scan "${fontFileName}" | egrep "family:|fullname:|postscriptname:" | awk -F ': ' '{print $2}')
                        fontPresent=$(egrep "${uniqueFonts//$'\n'/|}" <<< "${fontFullName}")
                        rm -f "${fontFileName}"
                        if [[ "${fontPresent}" ]]; then
                                echo "-map 0:t:${index}"
                        fi
                done <<< "$(jq '.streams[].index' <<< "${ATTACHMENTFFPROBE}")")
	fi
        echo "${SUBCOMMAND} ${ATTACHMENTCOMMAND}"

}

# Extracts chapter data from input file.
splitEpisodes () {
	chapters=${1}
	
	# Probes videos for chapter information and prints to text file
	chapterProbe=$(ffprobe -v error -i "${remuxOutputFile}" -print_format json -show_chapters)

        # Parses json file for the start time of each chapter.  Also counts number of chapters
        rawChapters=$(echo ${chapterProbe} | jq .chapters[].start_time | wc -l)
        # ffmpeg chapters start at zero.  Subtracting 1 to align with last chapter.
        totalChapters=$(echo $((${rawChapters} - 1)) | bc)

	i=0
	STARTSTOP=""
	# Builds a colon separated list of chapter start:end
	while [ ${i} -le ${totalChapters} ]; do
		first=${i}
	        last=$(echo $((${i} + ${CHAPTERSEPISODE} - 1)) | bc)
		if [ ${last} -gt ${totalChapters} ]; then
			last=${totalChapters}
		fi
	        STARTSTOP=$(echo "${STARTSTOP} ${first}:${last}")
       
		startTime=$(jq .chapters[${first}].start_time <<< "${chapterProbe}" | sed 's/\"//g')
	        endTime=$(jq .chapters[${last}].end_time <<< "${chapterProbe}" | sed 's/\"//g')
		ext=$(echo ${remuxOutputFile} | awk -F '.' '{print $NF}')
		outputFile=$(echo ${remuxOutputFile} | awk -F '/' '{print $NF}' | sed "s/.${ext}//g")
       	        chapterTimestamp="-ss ${startTime} -to ${endTime}"
		segmentFile=$(echo "${WIP}/${first}-${last}-${outputFile}.mkv")

		echo "Writing file for chapters ${first} thru ${last}"

		ffmpeg -v error -stats -y -fflags +genpts+igndts -i "${remuxOutputFile}" -map 0 -codec copy ${chapterTimestamp} -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${segmentFile}" < /dev/null

	        i=$(echo $((${i} + ${CHAPTERSEPISODE})) | bc)
	done
	CHAPTERFILES=$(ls ${WIP})
}

# Cuts out section on chapter markers specified.
chapterSelect () {
        startChapter=${1}
	endChapter=${2}

        # Probes videos for chapter information and prints to text file
        chapterProbe=$(ffprobe -v error -i "${remuxOutputFile}" -print_format json -show_chapters)

        # Parses json file for the start time of each chapter.  Also counts number of chapters
        totalChapters=$(echo ${chapterProbe} | jq .chapters[].start_time | wc -l)

        STARTSTOP=""
        # Builds a colon separated list of chapter start:end
        if [ ${endChapter} -gt ${totalChapters} ]; then
		endChapter=${totalChapters}
        fi
        STARTSTOP=$(echo "${STARTSTOP} ${startChapter}:${endChapter}")
                
        startTime=$(jq .chapters[${startChapter}].start_time <<< "${chapterProbe}" | sed 's/\"//g')
        endTime=$(jq .chapters[${endChapter}].end_time <<< "${chapterProbe}" | sed 's/\"//g')
        ext=$(echo ${remuxOutputFile} | awk -F '.' '{print $NF}')
	outputFile=$(echo ${remuxOutputFile} | awk -F '/' '{print $NF}' | sed "s/.${ext}//g")
        chapterTimestamp="-ss ${startTime} -to ${endTime}"
        segmentFile=$(echo "${WIP}/${startChapter}-${endChapter}-${outputFile}.mkv")
	
	echo "Writing file for chapters ${startChapter} thru ${endChapter}"
                
        ffmpeg -v error -stats -y -fflags +genpts+igndts -i "${remuxOutputFile}" -map 0 -codec copy ${chapterTimestamp} -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${segmentFile}" < /dev/null
}

# Generates video filters for vpp_qsv
generateFilters () {
	# ffprobe to determine if interlaced.  If yes, set yadif deinterlace filter.
	rawParams=$(ffprobe -v error -i "${remuxOutputFile}" -select_streams v:0 -show_entries stream=width,height,field_order,pix_fmt,sample_aspect_ratio,duration,display_aspect_ratio,r_frame_rate -show_entries stream_tags=NUMBER_OF_FRAMES)
	interlaced=$(echo ${rawParams} | grep -o 'field_order=[a-z]\+' | awk -F '=' '{print $2}' | head -1)
	frameRateNum=$(echo ${rawParams} | grep -o 'r_frame_rate=[0-9]*/[0-9]\+' | awk -F '=' '{print $2}' | awk -F '/' '{print $1}' | head -1)
	frameRateDenom=$(echo ${rawParams} | grep -o 'r_frame_rate=[0-9]*/[0-9]\+' | awk -F '=' '{print $2}' | awk -F '/' '{print $2}' | head -1)
	numOfFrames=$(echo ${rawParams} | grep -o 'NUMBER_OF_FRAMES=[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	inputBitDepth=$(echo ${rawParams} | grep -o 'pix_fmt=[a-z,0-9]\+' | awk -F '=' '{print $2}' | head -1)
	sar=$(echo ${rawParams} | grep -o 'sample_aspect_ratio=[0-9]*:[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	dar=$(echo ${rawParams} | grep -o 'display_aspect_ratio=[0-9]*:[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	width=$(echo ${rawParams} | grep -o 'width=[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	height=$(echo ${rawParams} | grep -o 'height=[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	duration=$(echo ${rawParams} | grep -o 'duration=[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	deinterlaced=""
	detelecine=""
	detelecineFrameRate=""

	# Checks for various interface types.  Uses QSV "advanced" de-interlace option if interlaced.
	case ${interlaced} in
	        tt) deinterlaced="2";;
	        bb) deinterlaced="2";;
	        tb) deinterlaced="2";;
	        bt) deinterlaced="2";;
	        *) deinterlaced="0";;
	esac

	if [ ${deinterlaced} -eq 2 ]; then
		echo "Detected interlaced video, checking for telecine"
		if [ ${numOfFrames} -lt 3600 ]; then
			readFrames=${numOfFrames}
		else
			readFrames=3600
		fi
		rawIdet=$(ffmpeg -filter:v idet -frames:v ${readFrames} -an -f rawvideo -y /dev/null -i "${remuxOutputFile}" 2>&1 | grep "frame detection" | tail -2)
		idetProg1=$(echo $rawIdet | head -1 | grep -o 'Progressive: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		idetProg2=$(echo $rawIdet | tail -1 | grep -o 'Progressive: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		idetTFF1=$(echo $rawIdet | head -1 | grep -o 'TFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		idetTFF2=$(echo $rawIdet | tail -1 | grep -o 'TFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		idetBFF1=$(echo $rawIdet | head -1 | grep -o 'BFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		idetBFF2=$(echo $rawIdet | tail -1 | grep -o 'BFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		idetUndet1=$(echo $rawIdet | head -1 | grep -o 'Undetermined: .*[0-9]' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		idetUndet2=$(echo $rawIdet | tail -1 | grep -o 'Undetermined: .*[0-9]' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
		progRatio1=$(awk "BEGIN {print ${idetProg1} / ${readFrames} * 100}")
		progRatio2=$(awk "BEGIN {print ( ${idetProg2} / ${readFrames} ) * 100}")

		if [ ${progRatio1} -ge 10 ] || [ ${progRatio2} -ge 10 ]; then
			echo "Telecine detected"
			detelecine="pullup,"
			newFrameRateNum=$(awk "BEGIN {print ${frameRateNum} * 0.8}")
			detelecineFrameRate="${newFrameRateNum}/${frameRateDenom}"
		else
			echo "Telecine was not detected"
		fi
	else
		echo "Detected progressive video"
	fi

	# ffmpeg to detect black bars for cropping.
	rawCrop1=$(ffmpeg -ss 0 -t 10 -i "${remuxOutputFile}" -vf fps=1/2,cropdetect=mode=black:reset=50,metadata=mode=print -f null - 2>&1 | awk '/crop=/ {a=$NF} END{print a}' | awk -F '=' '{print $2}')
	rawCrop2=$(ffmpeg -ss 300 -t 10 -i "${remuxOutputFile}" -vf fps=1/2,cropdetect=mode=black:reset=50,metadata=mode=print -f null - 2>&1 | awk '/crop=/ {a=$NF} END{print a}' | awk -F '=' '{print $2}')
	rawCrop3=$(ffmpeg -ss 1800 -t 10 -i "${remuxOutputFile}" -vf fps=1/2,cropdetect=mode=black:reset=50,metadata=mode=print -f null - 2>&1 | awk '/crop=/ {a=$NF} END{print a}' | awk -F '=' '{print $2}')

	IFS=$'\n'
	w1=$(echo ${rawCrop1} | awk -F ":" '{print $1}')
	w2=$(echo ${rawCrop2} | awk -F ":" '{print $1}')
	w3=$(echo ${rawCrop3} | awk -F ":" '{print $1}')
	wSort=(${w1} ${w2} ${w3})
	w=$(echo "${wSort[*]}" | sort -nr | head -n1)

	h1=$(echo ${rawCrop1} | awk -F ":" '{print $2}')
	h2=$(echo ${rawCrop2} | awk -F ":" '{print $2}')
	h3=$(echo ${rawCrop3} | awk -F ":" '{print $2}')
        hSort=(${h1} ${h2} ${h3})
        h=$(echo "${hSort[*]}" | sort -nr | head -n1)

	x1=$(echo ${rawCrop1} | awk -F ":" '{print $3}')
	x2=$(echo ${rawCrop2} | awk -F ":" '{print $3}')
	x3=$(echo ${rawCrop3} | awk -F ":" '{print $3}')
        xSort=(${x1} ${x2} ${x3})
        x=$(echo "${xSort[*]}" | sort -n | head -n1)

	y1=$(echo ${rawCrop1} | awk -F ":" '{print $4}')
	y2=$(echo ${rawCrop2} | awk -F ":" '{print $4}')
	y3=$(echo ${rawCrop3} | awk -F ":" '{print $4}')
        ySort=(${y1} ${y2} ${y3})
        y=$(echo "${ySort[*]}" | sort -n | head -n1)

	IFS=$' \t\n'

	echo "Crop detection results: w=${w} h=${h} x=${x} y=${y}"

	inputFormat=""

	if [[ "${inputBitDepth}" == *"p10le"* ]] || [[ "${inputBitDepth}" == *"p12le"* ]]; then
		echo "Detected 10/12bit source.  Setting to p0101e"
		inputFormat="p010le"
	else
		echo "Detected 8bit source.  Setting to nv12"
		inputFormat="nv12"
	fi

	
	# in the ratio equaling 16:9.  RESCALE=2 forces 4:3 ratio.  Else dynamically determine DAR and set SAR to 1:1.
	if [ ${RESCALE} -eq 1 ]; then
		echo "Manually altering dimensions for 16/9 video"
		h_float=$(awk "BEGIN {print ${w} / 1.777777778}" | bc)
		h_scale=$(printf "%.0f" ${h_float})
		FILTERS="deinterlace=${deinterlaced}:cw=${w}:ch=${h}:cx=${x}:cy=${y}:async_depth=4,${hwDL}format=${inputFormat},setsar=1:1,format=${inputFormat},${detelecine}hwupload,scale_qsv=w=${w}:h=${h_scale}:format=p010le"
	elif [ ${RESCALE} -eq 2 ]; then
		echo "Manually altering dimensions for 4/3 video"
		w_float=$(awk "BEGIN {print ${h} * 1.333}" | bc)
		w_scale=$(printf "%.0f" ${w_float})
		FILTERS="deinterlace=${deinterlaced}:cw=${w}:ch=${h}:cx=${x}:cy=${y}:async_depth=4,${hwDL}format=${inputFormat},setsar=1:1,format=${inputFormat},${detelecine}hwupload,scale_qsv=w=${w_scale}:h=${h}:format=p010le"
	else
		echo "Automatically detecting SAR/DAR"
		if [[ "${sar}" != "1:1" ]] && [ ! -z ${sar} ]; then
			sarRatio1=$(echo ${sar} | awk -F ':' '{print $1}')
			sarRatio2=$(echo ${sar} | awk -F ':' '{print $2}')
			sarRatio=$(awk "BEGIN {print ${sarRatio1} / ${sarRatio2}}")
			darRatio1=$(echo ${dar} | awk -F ':' '{print $1}')
			darRatio2=$(echo ${dar} | awk -F ':' '{print $2}')
			darRatio=$(awk "BEGIN {print ${darRatio1} / ${darRatio2}}")
	                ratio=$(awk "BEGIN {print ${darRatio} * ${sarRatio}}")
			ratioDiff=$(awk "BEGIN {print ${ratio} - 1.333}")
			ratioDiff=${ratioDiff#-}
			if [[ $(awk "BEGIN{print (${ratioDiff} < 0.2)}") -eq 1 ]]; then
				echo "Altering dimensions to fix aspect ratio to ~4/3"
                		w_float=$(awk "BEGIN {print ${h} * 1.333}" | bc)
				w_scale=$(printf "%.0f" ${w_float})
				FILTERS="deinterlace=${deinterlaced}:cw=${w}:ch=${h}:cx=${x}:cy=${y}:async_depth=4,${hwDL}format=${inputFormat},setsar=1:1,format=${inputFormat},${detelecine}hwupload,scale_qsv=w=${w_scale}:h=${h}:format=p010le"
			else
				echo "Altering dimensions to fix aspect ratio, widescreen"
				h_float=$(awk "BEGIN {print ${w} / ${ratio}}" | bc)
				h_scale=$(printf "%.0f" ${h_float})
				FILTERS="deinterlace=${deinterlaced}:cw=${w}:ch=${h}:cx=${x}:cy=${y}:async_depth=4,${hwDL}format=${inputFormat},setsar=1:1,format=${inputFormat},${detelecine}hwupload,scale_qsv=w=${w}:h=${h_scale}:format=p010le"
			fi
		elif [ -z ${sar} ]; then
			echo "SAR not set.  Setting to 1:1"
			FILTERS="deinterlace=${deinterlaced}:cw=${w}:ch=${h}:cx=${x}:cy=${y}:async_depth=4,${hwDL}format=${inputFormat},setsar=1:1,format=${inputFormat},${detelecine}hwupload,scale_qsv=w=${w}:h=${h}:format=p010le"
		elif [ ! -z ${detelecine} ]; then
			FILTERS="deinterlace=${deinterlaced}:cw=${w}:ch=${h}:cx=${x}:cy=${y}:async_depth=4:${hwDL}format=${inputFormat},${detelecine}hwupload,format=p010le"
		else
			FILTERS="deinterlace=${deinterlaced}:cw=${w}:ch=${h}:cx=${x}:cy=${y}:async_depth=4:format=p010le"
	        fi
	fi
	echo "Video filter result: ${FILTERS}"

}

convertEIA608 () {
	eiaTracks=$(ffprobe -i "${INPUTFILE}" -select_streams s -show_entries stream -v quiet -of json | jq -r '.streams[] | select(.codec_name == ("eia_608")) | .index')
	otherSubTracks=$(ffprobe -i "${INPUTFILE}" -select_streams s -show_entries stream -v quiet -of json | jq -r '.streams[] | select(.codec_name != ("eia_608")) | .index')
	srtMKVFile=$(echo ${INPUTFILE} | awk -F '/' '{print $NF}' | sed "s/.${ext}/-subs.mkv/g")
	mapEIATracks=$(for index in ${eiaTracks}; do
		echo "-map 0:${index}"
	done)
	ffmpeg -v error -stats -y -i "${INPUTFILE}" -vn -an ${mapEIATracks} -c:s srt "${WIP}/${srtMKVFile}"
	mapSubTracks=$(if [ -z ${otherSubTracks} ]; then
			echo "-map 1:s"
		else
			for index in ${otherSubTracks}; do
				echo "-map 0:${index}"
			done
			echo "-map 1:s"
		fi)
	ffmpeg -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -i "${WIP}/${srtMKVFile}" -codec copy -map_chapters 0 -map 0:v -map 0:a? ${mapSubTracks} -map 0:t? "${remuxOutputFile}" < /dev/null
	rm -f "${WIP}/${srtMKVFile}"
}

# Checks if end time for last chapter is after the video's duration
checkChapters () {
	inputFileCheck=$1
	LENGTH=$(ffprobe -loglevel error -i "${inputFileCheck}" -print_format json -show_entries format=duration | grep duration | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | bc)
	LASTCHAPTEREND=$(ffprobe -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | grep end_time | tail -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	LASTCHAPTERSTART=$(ffprobe -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | grep start_time | tail -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	CHAPTERCOUNT=$(ffprobe -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | jq -r ' .[].[].id' | wc -l)
	SECONDLASTCHAPTERENDINDEX=$(awk "BEGIN {print ${CHAPTERCOUNT} - 1}" | bc)
	SECONDLASTCHAPTEREND=$(ffprobe -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | jq -r --arg l ${SECONDLASTCHAPTERENDINDEX} '[.chapters[]].[$l|fromjson]' | grep end_time | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)

	LENGTH=$(ffprobe -loglevel error -i "${inputFileCheck}" -print_format json -show_entries format=duration | grep duration | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | bc)

	if [ -z ${LASTCHAPTEREND} ]; then
	        echo "${INPUTFILE} - No chapters present" > /dev/tty
		echo "0"
	elif [ ${LASTCHAPTEREND} -gt ${LENGTH} ]; then
	        echo "Fixing bad last chapter for ${INPUTFILE}" > /dev/tty
		echo "2"
	elif [ ! -z ${LASTCHAPTEREND} ] && [ ${SECONDLASTCHAPTEREND} -eq ${LASTCHAPTERSTART} ] && [ ${SECONDLASTCHAPTEREND} -eq ${LASTCHAPTEREND} ]; then
        	echo "${INPUTFILE} - Last chapter has no length.  Removing..." > /dev/tty
		echo "3"
	else
	        echo "${INPUTFILE} - All chapters valid" > /dev/tty
		echo "1"
	fi
}

repairChapters () {
	inputFileRepair=$1
	outputFileRepair=$2
	CHAPTERS=${WIP}/chapters.txt
	NEWCHAPTERS=${WIP}/newChapters.txt
	LASTCHAPTER=$(ffprobe -loglevel error -i "${inputFileRepair}" -print_format json -show_chapters | grep end_time | tail -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	TIMEBASE=$(ffprobe -loglevel error -i "${inputFileRepair}" -print_format json -show_chapters | grep time_base | head -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	LENGTHMS=$(ffprobe -loglevel error -i "${inputFileRepair}" -print_format json -show_entries format=duration | grep duration | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | bc)

	ffmpeg -v error -y -i "${inputFileRepair}" -f ffmetadata ${CHAPTERS} < /dev/null
	lastEnd=$(cat ${CHAPTERS} | grep "END=" | tail -1 | awk -F '=' '{print $2}')
	lastStart=$(cat ${CHAPTERS} | grep "START=" | tail -1 | awk -F '=' '{print $2}')
	LENGTHMS=$(awk "BEGIN {print ${LENGTHMS} * 1000}" | bc)
	sed -i "s/${lastEnd}/${LENGTHMS}/g" ${CHAPTERS}
	lastEndNew=$(cat ${CHAPTERS} | grep "END=" | tail -1 | awk -F '=' '{print $2}')
	if [ ${lastEndNew} -le ${lastStart} ]; then
			BADCHAPTER=3
	fi
	if [ ${BADCHAPTER} -eq 2 ]; then
		ffmpeg -v error -y -stats -fflags +genpts+igndts -i "${inputFileRepair}" -f ffmetadata -i ${CHAPTERS} -map 0 -codec copy -map_metadata 1 -map_chapters 1 -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${outputFileRepair}" < /dev/null
	elif [ ${BADCHAPTER} -eq 3 ]; then
	        ffmpeg -v error -y -i "${inputFileRepair}" -f ffmetadata ${CHAPTERS} < /dev/null
	        cat ${CHAPTERS} | head -n -5 > ${NEWCHAPTERS}
	        ffmpeg -v error -y -stats -fflags +genpts+igndts -i "${inputFileRepair}" -f ffmetadata -i ${NEWCHAPTERS} -map 0 -codec copy -map_metadata 1 -map_chapters 1 -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${outputFileRepair}" < /dev/null
		rm $CHAPTERS $NEWCHAPTERS
	fi
}

# Remuxes input file so that video tracks are grouped first, audio second, subs, third.  Simplifies track selection logic
# and resolves issues where weirdly ordered input files cause improper track selection.
ext=$(echo ${INPUTFILE} | awk -F '.' '{print $NF}')
remuxOutputFile=""
newExt=""

SUBFFPROBE=$(ffprobe -i "${INPUTFILE}" -select_streams s -show_entries stream -v quiet -of json)
NOMOVTEXT=$(jq '[.streams[] | select(.codec_name == ("mov_text"))]' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
NOEIA608=$(jq '[.streams[] | select(.codec_name == ("eia_608"))]' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
NOMSMPEG=$(ffprobe -i "${INPUTFILE}" -select_streams v -show_entries stream -v quiet -of json | jq '[.streams[] | select(.codec_name == ("msmpeg4v3"))] | length == 0')
inputFile=$(echo $INPUTFILE | awk -F '/' '{print $NF}')

# Checks if end time for last chapter is after the video's duration
BADCHAPTER=$(checkChapters "${INPUTFILE}")

echo "Remuxing file to re-order tracks"
if [[ "${ext}" == "avi" ]] || [[ "${ext}" == "mpg" ]] || [[ "${ext}" == "mp4" ]] || [[ "${ext}" == "m2ts" ]] || [ "${NOEIA608}" = 'false' ]; then
	if [ "${NOMOVTEXT}" = 'false' ] && [ "${NOMSMPEG}" = 'true' ]; then
		echo "Remuxing to MP4"
	        newExt="mp4"
	        remuxOutputFile=$(echo ${SCRATCHDIR}/${inputFile} | sed "s/.${ext}/-remux.${newExt}/g")
		if [ ${BADCHAPTER} -gt 1 ]; then
			repairChapters "${INPUTFILE}" "${remuxOutputFile}"
		else
			ffmpeg -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}"
		fi
	elif [ "${NOEIA608}" = 'false' ]; then
		echo "Remuxing to MKV and converting EIA608 subs"
		newExt="mkv"
		remuxOutputFile=$(echo ${SCRATCHDIR}/${inputFile} | sed "s/.${ext}/-remux.${newExt}/g")
                if [ ${BADCHAPTER} -gt 1 ]; then
			repairChapters "${INPUTFILE}" "${remuxOutputFile}"
			convertEIA608
		else
			convertEIA608
		fi
        elif [[ "${ext}" == "m2ts" ]]; then
		echo "Remuxing to M2TS"
		newExt="m2ts"
	        remuxOutputFile=$(echo ${SCRATCHDIR}/${inputFile} | sed "s/.${ext}/-remux.${newExt}/g")
                if [ ${BADCHAPTER} -gt 1 ]; then
			repairChapters "${INPUTFILE}" "${remuxOutputFile}"
                else
                        ffmpeg -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}"
                fi
	else
		echo "Remuxing to MKV"
	        newExt="mkv"
	        remuxOutputFile=$(echo ${SCRATCHDIR}/${inputFile} | sed "s/.${ext}/-remux.${newExt}/g")
                if [ ${BADCHAPTER} -gt 1 ]; then
			repairChapters "${INPUTFILE}" "${remuxOutputFile}"
                else
                        ffmpeg -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}"
                fi
	fi
else
	echo "Remuxing to MKV"
	newExt="mkv"
	remuxOutputFile=$(echo ${SCRATCHDIR}/${inputFile} | sed "s/.${ext}/-remux.${newExt}/g")
	if [ ${BADCHAPTER} -gt 1 ]; then
		repairChapters "${INPUTFILE}" "${remuxOutputFile}"
	else
		ffmpeg -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}"
	fi
fi


# Get ffprobe info to be used by other functions.
AUDIOFFPROBE=$(ffprobe -i "${remuxOutputFile}" -select_streams a -show_entries stream -v quiet -of json)
AV1PROBE=$(ffprobe -i "${remuxOutputFile}" -select_streams v -show_entries stream -v quiet -of json | jq '[.streams[] | select(.codec_name == ("av1"))]')
SUBFFPROBE=$(ffprobe -i "${remuxOutputFile}" -select_streams s -show_entries stream -v quiet -of json)
ATTACHMENTFFPROBE=$(ffprobe -v error -i "${remuxOutputFile}" -select_streams t -show_entries stream=index -show_entries stream_tags=filename -of json)
EMPTYAUDIOJSON=$(jq '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("jpn"))]' <<< "${AUDIOFFPROBE}" | jq -e '. | length == 0')

# Checks for subtitle track or untagged subtitle tracks.
EMPTYSUBJSON=$(jq -e '.streams | length == 0' <<< "${SUBFFPROBE}")
UNTAGGEDSUBJSON=$(jq '[.streams[] | select(.tags.language)]' <<< "${SUBFFPROBE}" | jq -e '. | length == 0')

# Checks for attachments
EMPTYATTACHMENTJSON=$(jq -e '.streams | length == 0' <<< "${ATTACHMENTFFPROBE}")

SWDECODE=$(ffprobe -i "${remuxOutputFile}" -select_streams v -show_entries stream -v quiet -of json | jq '[.streams[] | select(.profile == ("High 10") or .profile == ("Advanced Simple Profile") or .codec_name == ("mpeg1video") or .codec_name == ("vp8") or .codec_name == ("vc1") or .codec_name == ("msmpeg4v3") or .codec_name == ("mpeg4") or .profile == ("High 4:2:2") or .profile == ("High 4:4:4 Predictive") or .codec_name == ("wmv2") or .codec_name == ("wmv3"))] | length != 0')

if [[ "${SWDECODE}" == "true" ]]; then
	echo "Disabling hardware accelerated decoding"
        decodeAccel=""
        hwDL=""
elif [[ "${NOHWADECODE}" == "1" ]]; then
	echo "Manually disabled hardware accelerated decoding"
        decodeAccel=""
        hwDL=""
else
	echo "Using hardware accelerated decoding"
        decodeAccel="-hwaccel qsv"
        hwDL="hwdownload,"
fi

# If the -c option is used to provide the number of chapters per episode, in instances where a rip has all episodes in one MKV, this will call
# the function.  Otherwise the entire file will be processed.
# If -s is used, it will loop through the segments provided to extract the episodes based on chapter numbers provided.
# The segments start and end are colon sepearate, episodes are comma separated.
if [ ! -z ${CHAPTERSEPISODE} ]; then
        chapterProbe=$(ffprobe -v error -i "${remuxOutputFile}" -print_format json -show_chapters)
	EMPTYCHAPTERPROBE=$(ffprobe -v error -i "${remuxOutputFile}" -print_format json -show_chapters | jq -r '.[] | length == 0')
	if [[ "${EMPTYCHAPTERPROBE}" != "true" ]]; then
	        echo "Splitting file in ${CHAPTERSEPISODE} chapter segments"
	        splitEpisodes ${CHAPTERSEPISODE}
	else
		echo "No chapters found.  Will not split file."
		CHAPTERFILES=$(echo "${remuxOutputFile}")
	fi
elif [ ! -z ${CHAPSELECT} ]; then
        chapterProbe=$(ffprobe -v error -i "${remuxOutputFile}" -print_format json -show_chapters)
	EMPTYCHAPTERPROBE=$(ffprobe -v error -i "${remuxOutputFile}" -print_format json -show_chapters | jq -r '.[] | length == 0')
	if [[ "${EMPTYCHAPTERPROBE}" != "true" ]]; then
	        echo "Using user provided start/end chapters."
		segments=$(echo ${CHAPSELECT} | sed 's/,/ /g')
		for segment in ${segments} ; do
			STARTCHAP=$(echo ${segment} | awk -F ':' '{print $1}')
			ENDCHAP=$(echo ${segment} | awk -F ':' '{print $2}')
			chapterSelect ${STARTCHAP} ${ENDCHAP}
		done
		CHAPTERFILES=$(ls ${WIP})
	else
		echo "No chapters found.  Will not split file."
		CHAPTERFILES=$(echo "${remuxOutputFile}")
	fi
else
	echo "Not splitting input file"
	CHAPTERFILES=$(echo "${remuxOutputFile}")
fi

# Creates lanuage English selection parameters for audio and subtitles.  If ANIME option is enabled, also selects Japanese tracks.
if [ ${ANIME} -eq 1 ]; then
	echo "Selecting English and Japanese audio/subtitle tracks."
	SELECTEDAUDIO=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("jpn"))]' <<< "${AUDIOFFPROBE}")
        if [ "${UNTAGGEDSUBJSON}" = 'true' ]; then
                if [ "${EMPTYSUBJSON}" = 'true' ]; then
                        echo "No subtitle track"
                else
			SELECTEDSUBS=$(jq -r '[.streams[]]' <<< "${SUBFFPROBE}")
                fi
        else
		SELECTEDSUBS=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("zxx") or .tags.language == ("enm"))]' <<< "${SUBFFPROBE}")
		EMPTYSELECTEDSUBJSON=$(jq -e '.[] | length == 0' <<< "${SELECTEDSUBS}")
                if [ "${EMPTYSELECTEDSUBJSON}" = 'true' ]; then
			echo "No English subtitle tracks found.  Looking for mistagged \"Japanese\" tracks"
			SELECTEDSUBS=$(jq -r '[.streams[] | select(.tags.language == ("jpn"))]' <<< "${SUBFFPROBE}")
			EMPTYSELECTEDSUBJSON=$(jq -e '.[] | length == 0' <<< "${SELECTEDSUBS}")
                	if [ "${EMPTYSELECTEDSUBJSON}" = 'true' ]; then
				SELECTEDSUBS=$(jq -r '[.streams[]]' <<< "${SUBFFPROBE}")
				echo "Did not find English or Japanese subtitle tracks.  Selecting all subtitles."
			else
				echo "Found \"Japanese\" subtitles"
			fi
		fi
	fi

elif [ ${KOREAN} -eq 1 ]; then
        echo "Selecting English and Korean audio/subtitle tracks."
        SELECTEDAUDIO=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("kor"))]' <<< "${AUDIOFFPROBE}")
        if [ "${UNTAGGEDSUBJSON}" = 'true' ]; then
                if [ "${EMPTYSUBJSON}" = 'true' ]; then
                        echo "No subtitle track"
                else
                        SELECTEDSUBS=$(jq -r '[.streams[]]' <<< "${SUBFFPROBE}")
                fi
        else
		SELECTEDSUBS=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("zxx") or .tags.language == ("enm"))]' <<< "${SUBFFPROBE}")
        fi
elif [ ${CHINESE} -eq 1 ]; then
        echo "Selecting English and Chinese audio/subtitle tracks."
	SELECTEDAUDIO=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("chi") or .tags.language == ("zho"))]' <<< "${AUDIOFFPROBE}")
        if [ "${UNTAGGEDSUBJSON}" = 'true' ]; then
                if [ "${EMPTYSUBJSON}" = 'true' ]; then
                        echo "No subtitle track"
                else
                        SELECTEDSUBS=$(jq -r '[.streams[]]' <<< "${SUBFFPROBE}")
                fi
        else
                SELECTEDSUBS=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("zxx") or .tags.language == ("enm"))]' <<< "${SUBFFPROBE}")
        fi
else
	echo "Selecting English audio/subtitle tracks."
        SELECTEDAUDIO=$(jq -r '[.streams[] | select(.tags.language == ("eng"))]' <<< "${AUDIOFFPROBE}")
        if [ "${UNTAGGEDSUBJSON}" = 'true' ]; then
        	if [ "${EMPTYSUBJSON}" = 'true' ]; then
			echo "No subtitle track"
		else
			SELECTEDSUBS=$(jq -r '[.streams[]]' <<< "${SUBFFPROBE}")
		fi
	else
		SELECTEDSUBS=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("zxx"))]' <<< "${SUBFFPROBE}")
	fi
fi

# If the -f 1 option is used, all audio tracks will be converted to OPUS.
# If a lossless Dolby/DTS codec exists for English and/or Japanese, the lossy tracks
# will be discarded in favor of converting only the lossless track.
if [ ${ENGLISHSELECTION} -eq 1 ]; then
	echo "Remux + English audio/subtitle selection only"
	remuxOnly
elif [ ${AUDIOCONVERSION} -eq 1 ] || [ "${AV1PROBE}" != "[]" ]; then
	if [ "${AV1PROBE}" != "[]" ]; then
		echo "Video codec is already AV1"
	fi
	echo "Converting audio only"
	audioConversionOnly
else
	echo "Generating video filter parameters"
	generateFilters
	av1Encode
fi

# WIP cleanup
echo "Cleaning up WIP files/folders"
rm -f "${remuxOutputFile}"
rm -rf ${WIP}
