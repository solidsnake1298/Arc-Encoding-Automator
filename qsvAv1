#!/bin/bash

###########################
# Assumes jellyfin-ffmpeg is installed and symlinked in /usr/bin.
# Most functions may work with vanilla ffmpeg, but may require additional Intel drivers.
# Removing Dolby Vision function requires jellyfin-ffmpeg 7.0.2-4 and newer.
# Must have jq and bc installed.
# User running this script must be in render group.  Requires user logout if added to group.
##########################

# Provides absolute paths for ffmpeg/ffprobe.  More cron friendly.
ffmpeg="/usr/lib/jellyfin-ffmpeg/ffmpeg"
ffprobe="/usr/lib/jellyfin-ffmpeg/ffprobe"

# Variable initialization.  Work-in-progress initialization and cleanup.
INPUTFILE=""
CHAPTERSEPISODE=
CHAPSELECT=
ANIME=0
KOREAN=0
CHINESE=0
SPANISH=0
FILTERS=""
CHAPTERFILES=""
FINALAUDIO=""
SELECTEDAUDIO=""
SELECTEDSUBS=""
SUBCOMMAND=""
ATTACHMENTCOMMAND=""
NOHWADECODE=0
SCRATCHDIR=""
ENGLISHSELECTION=0
AUDIOCONVERSION=0
EMPTYCHAPTERPROBE=""
FRAMERATE=""
EXITCODE=0
FORCEDETELECINE=0

# show_help function
show_help() {
    echo "Usage: $(basename "$0") [-i] FILE_TO_ENCODE [-c NUMBER|-s NUMBER] [-w PATH_TO_SCRATCH_DIRECTORY] [-a|k|m|h|e|o]"
    echo
    echo "	-i INPUTFILE		The file you wish to encode/remux"
    echo "	-c NUMBER			For files with multiple episodes, but a consistent number of chapters"
    echo "						per episode, provide an integer and the input file will be split into multiple files"
    echo "						with the number of chapters specified in each file."
    echo "	-C NUMBER(s)		Similar to -c, but can handle instances with one or more episodes have a different"
    echo "						number of chapters in the episode. Start and end chapters are colon separate, files"
    echo "						are comma separate."
    echo "						Example: -C \"00:05,06:10,11:15,16:20,21:25,26:30,31:35,36:40,41:45,46:50,51:55,56:60,61:65,66:70\""
    echo "						In this example the first episode has 6 chapters while the rest have 5."
    echo "	-w DIRECTORY_PATH	You can specify a directory that this script will use as a scratch/WIP directory."
    echo "						This is can help reduce disk I/O and make the file transfers much more sequential and, thus, faster."
    echo "	-a					If you wish to select Japanese language audio tracks, enable this option."
    echo "	-k					If you wish to select Korean language audio tracks, enable this option."
    echo "	-m					If you wish to select Chinese language audio tracks, enable this option.  This should select the most common dialets."
    echo "	-s					If you wish to select Spanish language audio tracks, enable this option."
    echo "	-h					Disables hardware accelerated DEcoding.  Useful if the source video uses a codec I haven't added to the block list."
    echo "	-e					When this option is enabled the input file will be remuxed as well as English audio/subtitle selection."
    echo "						No encoding will occur.  Can be combined with a, k, and m."
    echo "	-o					When this option is enabled only the audio will be re-encoded to OPUS, when applicable.  Can be combined"
    echo "						with options a, k, and m.  This option will be ignored if option e is also enabled."
    echo "	-t					Forces de-telecine when previous run did was not able to conclusively detect telecine.  Specify a mode."
    echo "						1) 24fps in 30fps mode  2) 24fps in 60fps mode  3) Progressive in interlaced mode"
    echo
    return
}

# Reads input paramamters
while getopts :t:i:c:C:w:akmheos option; do
    case ${option} in
        i) INPUTFILE=${OPTARG};;
        c) CHAPTERSEPISODE=${OPTARG};;
        a) ANIME=1;;
        k) KOREAN=1;;
		m) CHINESE=1;;
		s) SPANISH=1;;
		C) CHAPSELECT=${OPTARG};;
		h) NOHWADECODE=1;;
		w) SCRATCHDIR=${OPTARG};;
		e) ENGLISHSELECTION=1;;
		o) AUDIOCONVERSION=1;;
		t) FORCEDETELECINE=${OPTARG};;
		h) show_help ; exit 0;;
        \?) echo "Invalid option" ; show_help ; exit 1;;
	esac
done

# Checks for required input file name
if [ -z "${INPUTFILE}" ]; then
        echo "No input file was provided."
        exit 1
fi
# If no SCRATCHDIR provided, use current dir
if [ -z "${SCRATCHDIR}" ]; then
	SCRATCHDIR="."
fi

WIP=${SCRATCHDIR}/WIP
mkdir -p ${WIP}

checkExitCode () {
	function=$1
	if [ $EXITCODE -eq -1 ]; then
		echo "Encode completed successfully."
		# WIP cleanup
		echo "Cleaning up WIP files/folders"
		rm -f "${remuxOutputFile}"
		rm -rf "${WIP}"
		exit 0
	elif [ $EXITCODE -eq -2 ]; then
		echo "Telecine detection could not determine how to proceed for ${INPUTFILE}."
		echo "Manually analyze file and manually set telecine option."
		exit 2
	elif [ $EXITCODE -ne 0 ]; then
		echo "FFmpeg returned a non-zero exit code in ${function}.  Leaving WIP files in place and quitting."
		exit 1
	fi
}

# Uses Intel QSV to encode the original AV1.  Maps the audio tracks for the selected languages, and converts to them to OPUS.
# Includes attachments if present.  If splitting out episodes from a MKV that came off the disc as a single file, it will loop through for each episode.
# If using jellyfin-ffmpeg7.0.2-4 and newer, DV 7.6 and 8 will automatically be stripped.
av1Encode () {
	inputFile=$1

	echo "Converting to AV1 ${INPUTFILE}"
	if [ -z ${CHAPTERSEPISODE} ] && [ -z ${STARTCHAP} ] && [ -z ${ENDCHAP} ]; then
		outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
	elif [[ "${EMPTYCHAPTERPROBE}" == "true" ]]; then
		outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
	else
	startChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $1}')
	endChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $2}')
	outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-${startChapter}-${endChapter}.mkv/g")
	fi
	${ffmpeg} \
		-y \
		-init_hw_device vaapi=va:,driver=iHD,kernel_driver=i915 \
		-hide_banner \
		-stats \
		-fflags +genpts+igndts \
		-v error \
		-init_hw_device qsv=qs@va \
		-filter_hw_device qs \
		${decodeAccel} \
		-hwaccel_output_format qsv \
		-extra_hw_frames 40 \
		-i "${inputFile}" \
		-filter_complex "[0]${FILTERS}[vOut]" \
		-map ["vOut"]:v \
		-c:v av1_qsv \
		-q:v 22 \
		-preset veryslow \
		-look_ahead_depth 40 \
		-map_chapters 0 \
		${audioCommand} \
		${subCommand} \
		${FRAMERATE} \
		-disposition:s 0 \
		-low_delay_brc 1 \
		-extbrc 1 \
		-adaptive_i 1 \
		-adaptive_b 1 \
		-b_strategy 1 \
		-bf 39 \
		-max_muxing_queue_size 2048 \
		-max_interleave_delta 0 \
		-avoid_negative_ts disabled \
		"${outputFile}" < /dev/null
	EXITCODE=$?
	checkExitCode "av1Encode"

# Rechecks chapters, but only if present in input file
# Duration can shift slightly during encoding, which causes the last chapter
# to, potentially, end after the duration.
	if [ ${BADCHAPTER} -ne 0 ]; then
		echo "Rechecking output file chapters"
		BADCHAPTER=$(checkChapters "${outputFile}")
		if [ ${BADCHAPTER} -gt 1 ]; then
			newOutputFile=$(echo ${outputFile} | sed 's/.mkv/-chapterFix.mkv/g')
			echo "Output file has bad chapters.  Duration can change slightly during encoding, triggering this issue."
			repairChapters "${outputFile}" "${newOutputFile}"
			mv "${newOutputFile}" "${outputFile}"
		else
			echo "All chapters valid in output file"
		fi
	fi
}

# Only remuxes tracks with selected languages
audioRemuxOnly () {
        inputFile=$1
                
	echo "Remuxing ${INPUTFILE}"
        if [ -z ${CHAPTERSEPISODE} ] && [ -z ${STARTCHAP} ] && [ -z ${ENDCHAP} ]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
        elif [[ "${EMPTYCHAPTERPROBE}" == "true" ]]; then
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-all.mkv/g")
        else
                startChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $1}')
                endChapter=$(echo ${inputFile} | awk -F '/' '{print $NF}' | awk -F '-' '{print $2}')
                outputFile=$(echo ${INPUTFILE} | sed "s/.${ext}/-${startChapter}-${endChapter}.mkv/g")
        fi
        ${ffmpeg} \
                -y \
                -hide_banner \
                -stats \
                -fflags +genpts+igndts \
                -v error \
                -i "${inputFile}" \
                -map_chapters 0 \
                -map 0:v:0 \
                -c:v copy \
                ${audioCommand} \
                ${subCommand} \
                -disposition:s 0 \
                -max_muxing_queue_size 2048 \
                -max_interleave_delta 0 \
                -avoid_negative_ts disabled \
                "${outputFile}" < /dev/null
        EXITCODE=$?
	checkExitCode "audioRemuxOnly"

# Rechecks chapters, but only if present in input file
# Duration can shift slightly during encoding, which causes the last chapter
# to, potentially, end after the duration.
if [ ${BADCHAPTER} -ne 0 ]; then
        echo "Rechecking output file chapters"
        BADCHAPTER=$(checkChapters "${outputFile}")
        if [ ${BADCHAPTER} -gt 1 ]; then
                newOutputFile=$(echo ${outputFile} | sed 's/.mkv/-chapterFix.mkv/g')
                echo "Output file has bad chapters.  Duration can change slightly during encoding, triggering this issue."
                repairChapters "${outputFile}" "${newOutputFile}"
                mv "${newOutputFile}" "${outputFile}"
        else
                echo "All chapters valid in output file"
        fi
fi
}

# Selects audio tracks for processing.  If lossless tracks are present for a language, lossy tracks for that language are ignored.
audioMapping () {
	# checks if audio.json is empty due to untagged streams
	# if lossless tracks are present, ignore lossy tracks
	if [ "${EMPTYAUDIOJSON}" = 'true' ]; then 
		echo "Selected audio returned no results.  Selecting all audio tracks." 1>&2 | tee /dev/tty /dev/stderr
		FINALAUDIO=$(jq -r '[.streams.[]] | .[] | .index' <<< "${AUDIOFFPROBE}")
		SELECTEDAUDIO=$(jq -r '[.streams.[]]' <<< "${AUDIOFFPROBE}")
	else
		for lang in ${audioLanguages}; do
			lossless=$(jq -r --arg langs "${lang}" '.[] | select(.tags.language == ($langs))'  <<< "${SELECTEDAUDIO}" | egrep -i "dts-hd ma|truehd|flac" | grep -v "title" | head -1)
			codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
			if [ ! -z "${lossless}" ]; then 
				echo "Finding lossless ${lang} audio tracks, if any" 1>&2 | tee /dev/tty /dev/stderr
				codec=$(echo ${lossless} | awk -F ': ' '{print $2}' | sed 's/,//g' | sed 's/\"//g')
				if [ ! -z "`echo ${codec} | grep -i dts`" ]; then 
					finalAudio=$(jq -r --arg langs "${lang}" '.[] | select((.profile | values | startswith("DTS-HD MA")) and .tags.language == ($langs)) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found DTS HD Master Audio track.  Ignoring other English tracks" 1>&2 | tee /dev/tty /dev/stderr
				elif [ ! -z "`echo ${codec} | grep -i truehd`" ]; then 
					finalAudio=$(jq -r --arg langs "${lang}" '.[] | select(.codec_name == ("truehd") and .tags.language == ($langs)) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found Dolby TrueHD audio track.  Ignoring other English tracks" 1>&2 | tee /dev/tty /dev/stderr
				elif [ ! -z "`echo ${codec} | grep -i flac`" ]; then 
					finalAudio=$(jq -r --arg langs "${lang}" '.[] | select(.codec_name == ("flac") and .tags.language == ($langs)) | .index' <<< "${SELECTEDAUDIO}")
					echo "Found FLAC audio track.  Ignoring other English tracks" 1>&2 | tee /dev/tty /dev/stderr
				fi   
			else 
				finalAudio=$(jq -r --arg langs "${lang}" '.[] | select(.tags.language == ($langs)) | .index' <<< "${SELECTEDAUDIO}")
				echo "No lossless ${lang} tracks found" 1>&2 | tee /dev/tty /dev/stderr
			fi
			FINALAUDIO="${FINALAUDIO} ${finalAudio}"
		done
	fi
	# Catches edge cases where audio selection logic fails
	if [ -z "${FINALAUDIO}" ]; then
		echo "Audio track selection did no return any index numbers.  Selecting English and specified non-english tracks, if applicable." 1>&2 | tee /dev/tty /dev/stderr
		FINALAUDIO=$(jq -r '.[] | .index' <<< "${SELECTEDAUDIO}")
	fi
	
	firstTrack=$(jq -r '.streams[0] | .index' <<< "${AUDIOFFPROBE}" | bc)
	skipConversion=$(jq -r '.[] | select(.codec_name == ("aac") or .codec_name == ("mp3") or .codec_name == ("flac") or .codec_name ==("opus") or .codec_name ==("vorbis")) | .index' <<< "${SELECTEDAUDIO}")
	audioLoop=""
	trackNumber=0
	audioCommand=$(for rawIndex in ${FINALAUDIO}; do
		contains ${rawIndex} ${skipConversion}
		compatCodec=$(echo $? | bc)
		index=$(awk "BEGIN {print ${rawIndex} - ${firstTrack}}" | bc)
		if [ ${compatCodec} -eq 0 ] || [ ${ENGLISHSELECTION} -eq 1 ]; then
	                audioLoop="-map 0:a:${index} -c:a:${trackNumber} copy"
			echo "Audio codec for track ${trackNumber} is already FOSS or widely compatible." 1>&2 | tee /dev/tty /dev/stderr
			((++trackNumber))
			echo ${audioLoop}
		else
			audioLoop="-map 0:a:${index} -c:a:${trackNumber} libopus -vbr on -compression_level 10 -application audio"
			channels=$(jq --arg l ${index} '.streams[$l|fromjson].channels' <<< "${AUDIOFFPROBE}")
			echo "Track ${trackNumber} will be converted to OPUS" 1>&2 | tee /dev/tty /dev/stderr
			if [ ${channels} -gt 2 -a ${channels} -lt 6 ]; then
				audioLoop="-mapping_family 1 -ac ${channels}"
			fi
			((++trackNumber))
			echo ${audioLoop}
		fi
	done)
	echo "${audioCommand}"
}

set +e
contains() {
	local e match="${1}"
	shift
	for e; do
		[[ "${e}" == "${match}" ]] && return 0
	done
	return 1
}

# Selects and maps English and Japanese subtitle tracks.
subMapping () {
	firstTrack=$(jq -r '.streams[0] | .index' <<< "${SUBFFPROBE}" | bc)
	noMovText=$(jq '[.streams[] | select(.codec_name == ("mov_text"))]' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
	# Checks for no subtitle track.  Common for older fansubs with burned in subtitles.
	if [ "${EMPTYSUBJSON}" = 'true' ] || [ "${SELECTEDSUBS}" == "[]" ]; then
		echo "No subtitles detected" 1>&2 | tee /dev/tty /dev/stderr
		SUBCOMMAND="-sn"
	elif [ "${noMovText}" = 'false' ]; then
		echo "Converting mov_text to SRT" 1>&2 | tee /dev/tty /dev/stderr
		trackNumber=0
		SUBCOMMAND=$(while read rawIndex; do
			index=$(awk "BEGIN {print ${rawIndex} - ${firstTrack}}" | bc)
			noMovText=$(jq --arg l ${index} '.streams[$l|fromjson] | select(.codec_name == ("mov_text"))' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
			if [ "${noMovText}" = 'false' ]; then
				subLoop="-map 0:s:${index} -c:s:${trackNumber} srt"
				((++trackNumber))
				echo ${subLoop}
			else
				subLoop="-map 0:s:${index} -c:s:${trackNumber} copy"
				((++trackNumber))
				echo ${subLoop}
			fi
		done <<< "$(jq '.[].index' <<< "${SELECTEDSUBS}")")
	else
	# If audio language tags are not present, it is safe to assume subtitle language tags aren't either
		SUBCOMMAND="-c:s copy"
		echo "Mapping subtitle tracks" 1>&2 | tee /dev/tty /dev/stderr
		while read rawIndex; do
			index=$(awk "BEGIN {print ${rawIndex} - ${firstTrack}}" | bc)
			SUBCOMMAND="${SUBCOMMAND} -map 0:s:${index}"
		done <<< "$(jq '.[].index' <<< "${SELECTEDSUBS}")"
	fi
	
	index=0
	fonts=""
	firstAttachmentTrack=$(jq -r '.streams[0] | .index' <<< "${ATTACHMENTFFPROBE}" | bc)
        # Checks for attachments.  Only expected when using ASS subtitles.
        if [ "${EMPTYATTACHMENTJSON}" = 'true' ]; then
		echo "Including all attachments, if any" 1>&2 | tee /dev/tty /dev/stderr
        	ATTACHMENTCOMMAND="-map 0:t?"
	elif [ "${SUBCOMMAND}" = '-sn' ]; then
		echo "No subtitle tracks, dropping all attachments" 1>&2 | tee /dev/tty /dev/stderr
		ATTACHMENTCOMMAND=""
        else
		echo "Extracting fonts used by selected ASS tracks" 1>&2 | tee /dev/tty /dev/stderr
		# When there are fonts, pulls in ASS sub style lines from the tracks selected
		for subIndex in `jq '.[].index' <<< "${SELECTEDSUBS}"`; do
			index=$(awk "BEGIN {print ${subIndex} - ${firstTrack}}" | bc)
			isSubASS=$(jq --arg l ${index} '.streams[$l|fromjson] | select(.codec_name == ("ass"))' <<< ${SUBFFPROBE} | jq -e '. | length != 0')
			if [ "${isSubASS}" = 'true' ]; then
				newFonts=$(${ffmpeg} -v error -stats -i "${remuxOutputFile}" -vn -an -map 0:s:${index} -f ass - | egrep "^Style:" | awk -F ':' '{print $2}' | awk -F ',' '{print $2}')
				fonts+="${newFonts}"
			fi
		done
		echo "Dumping attachments and dropping unused fonts" 1>&2 | tee /dev/tty /dev/stderr
                uniqueFonts=$(echo -e "${fonts}" | sort | uniq)
                ATTACHMENTCOMMAND=$(while read attachmentIndex ; do
                        index=$(awk "BEGIN {print ${attachmentIndex} - ${firstAttachmentTrack}}" | bc)
                        fontFileName=$(jq --arg l ${index} '.streams[$l|fromjson].tags.filename' <<< ${ATTACHMENTFFPROBE})
                        ${ffmpeg} -v fatal -dump_attachment:t:${index} "${fontFileName}" -i "${INPUTFILE}"
                        fontFullName=$(fc-scan "${fontFileName}" | egrep "family:|fullname:|postscriptname:" | awk -F ': ' '{print $2}')
                        fontPresent=$(egrep "${uniqueFonts//$'\n'/|}" <<< "${fontFullName}")
                        rm -f "${fontFileName}"
                        if [[ "${fontPresent}" ]]; then
                                echo "-map 0:t:${index}"
                        fi
                done <<< "$(jq '.streams[].index' <<< "${ATTACHMENTFFPROBE}")")
	fi
        echo "${SUBCOMMAND} ${ATTACHMENTCOMMAND}"
}

# Extracts chapter data from input file.
splitEpisodes () {
	chapters=${1}
	
	# Probes videos for chapter information and prints to text file
	chapterProbe=$(${ffprobe} -v error -i "${remuxOutputFile}" -print_format json -show_chapters)

        # Parses json file for the start time of each chapter.  Also counts number of chapters
        rawChapters=$(echo ${chapterProbe} | jq .chapters[].start_time | wc -l)
        # ffmpeg chapters start at zero.  Subtracting 1 to align with last chapter.
        totalChapters=$(echo $((${rawChapters} - 1)) | bc)

	i=0
	STARTSTOP=""
	# Builds a colon separated list of chapter start:end
	while [ ${i} -le ${totalChapters} ]; do
		first=${i}
	        last=$(echo $((${i} + ${CHAPTERSEPISODE} - 1)) | bc)
		if [ ${last} -gt ${totalChapters} ]; then
			last=${totalChapters}
		fi
	        STARTSTOP=$(echo "${STARTSTOP} ${first}:${last}")
       
		startTime=$(jq .chapters[${first}].start_time <<< "${chapterProbe}" | sed 's/\"//g')
	        endTime=$(jq .chapters[${last}].end_time <<< "${chapterProbe}" | sed 's/\"//g')
		ext=$(echo ${remuxOutputFile} | awk -F '.' '{print $NF}')
		outputFile=$(echo ${remuxOutputFile} | awk -F '/' '{print $NF}' | sed "s/.${ext}//g")
       	        chapterTimestamp="-ss ${startTime} -to ${endTime}"
		segmentFile=$(echo "${WIP}/${first}-${last}-${outputFile}.mkv")

		echo "Writing file for chapters ${first} thru ${last}"
		if [ ${ENGLISHSELECTION} -eq 1 ]; then
			segmentFile=$(echo "${first}-${last}-${outputFile}.mkv")
			${ffmpeg} -v error -stats -y -fflags +genpts+igndts -i "${remuxOutputFile}" -map 0 -c:v copy ${audioCommand} ${subCommand} ${chapterTimestamp} -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${segmentFile}" < /dev/null
		else
			${ffmpeg} -v error -stats -y -fflags +genpts+igndts -i "${remuxOutputFile}" -map 0 -codec copy ${chapterTimestamp} -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${segmentFile}" < /dev/null
		fi
		EXITCODE=$?
		checkExitCode "splitEpisodes $first $last"
	        i=$(echo $((${i} + ${CHAPTERSEPISODE})) | bc)
	done

	if [ ${ENGLISHSELECTION} -eq 1 ]; then
		EXITCODE=-1
		checkExitCode "split + language selection"
	else
		CHAPTERFILES=$(find ${WIP} -type f | sort)
	fi
}

# Cuts out section on chapter markers specified.
chapterSelect () {
        startChapter=${1}
	endChapter=${2}

        # Probes videos for chapter information and prints to text file
        chapterProbe=$(${ffprobe} -v error -i "${remuxOutputFile}" -print_format json -show_chapters)

        # Parses json file for the start time of each chapter.  Also counts number of chapters
        totalChapters=$(echo ${chapterProbe} | jq .chapters[].start_time | wc -l)

        STARTSTOP=""
        # Builds a colon separated list of chapter start:end
        if [ ${endChapter} -gt ${totalChapters} ]; then
		endChapter=${totalChapters}
        fi
        STARTSTOP=$(echo "${STARTSTOP} ${startChapter}:${endChapter}")
                
        startTime=$(jq .chapters[${startChapter}].start_time <<< "${chapterProbe}" | sed 's/\"//g')
        endTime=$(jq .chapters[${endChapter}].end_time <<< "${chapterProbe}" | sed 's/\"//g')
        ext=$(echo ${remuxOutputFile} | awk -F '.' '{print $NF}')
	outputFile=$(echo ${remuxOutputFile} | awk -F '/' '{print $NF}' | sed "s/.${ext}//g")
        chapterTimestamp="-ss ${startTime} -to ${endTime}"
        segmentFile=$(echo "${WIP}/${startChapter}-${endChapter}-${outputFile}.mkv")
	
	echo "Writing file for chapters ${startChapter} thru ${endChapter}"
                
        ${ffmpeg} -v error -stats -y -fflags +genpts+igndts -i "${remuxOutputFile}" -map 0 -codec copy ${chapterTimestamp} -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${segmentFile}" < /dev/null
	EXITCODE=$?
	checkExitCode "ChapterSelect ${startChapter} ${endChapter}"
}

# Generates filter based on results of probe
generateFilters () {
	if [ ${setSar} -eq 1 ]; then 
		sar="setsar=1:1,"
	else 
		sar=""
	fi
	if [ ${setHWDL} -eq 1 ]; then
		hwDownload="hwdownload,"
	else
		hwDownload=""
	fi
	if [ ${setHWUL} -eq 1 ]; then
		hwUpload="hwupload,"
	else
		hwUpload=""
	fi
	if [ ${setInFormat} -eq 1 ]; then
		inFormat="format=${inputFormat},"
	else
		inFormat=""
	fi
	if [ ${setDetelecine} -eq 1 ]; then
		if [ ${frameRateDenom} -ne 1 ]; then 
			frameRateInt=$(printf "%.0f" `awk "BEGIN {print (( ${frameRateNum} + 1 ) / ${frameRateDenom})}"`)
			newFrameRateInt=$(printf "%.0f" `awk "BEGIN {print (( ${newFrameRateNum} + 1 ) / ${frameRateDenom})}"`)
		else
			frameRateInt=${frameRateNum}
			newFrameRateInt=${newFrameRateNum}
		fi   
		if [ ${frameRateInt} -ge 48 ]; then
			dejudderValue=20
		else
			dejudderValue=4
		fi
		detelecine="pullup,dejudder=${dejudderValue},"
	else
		detelecine=""
	fi   
	if [ ${setDeinterlace} -eq 1 ]; then 
		if [ ${setFramerate} -eq 1 ]; then 
			deinterlace="vpp_qsv=rate=0:deinterlace=2:framerate=${newFrameRate},"
		else 
			deinterlace="vpp_qsv=rate=0:deinterlace=2,"
		fi
	else
		deinterlace=""
	fi
        if [ ${x} -eq 0 ] && [ ${y} -eq 0 ]; then
                crop=""
        else
                crop="vpp_qsv=cw=${w}:ch=${h}:cx=${x}:cy=${y}:scale_mode=5,"
        fi
	if [ ${setScale} -eq 1 ]; then 
		scale="scale_qsv=w=${w_scale}:h=${h_scale}:mode=hq:format=p010le"
	else
		scale="scale_qsv=format=p010le"
	fi
	if [ ${setProgInInterlaced} -eq 1 ]; then
		progInInterlaced="il=l=d:c=d,split[o][e];[o]crop=iw:ih/2:0:0[odd];[e]crop=iw:ih/2:0:ih/2[even];[odd][even]vstack,il=l=i:c=i[rejoined];[rejoined]"
	else
		progInInterlaced=""
	fi
	echo "${hwDownload}${inFormat}${progInInterlaced}${detelecine}${hwUpload}${deinterlace}${crop}${sar}${scale}"
}

# Probes file and generates video filters parameters
generateFilterParameters () {
	inputFile=$1
	# ffprobe to determine if interlaced.  If yes, set bwdif deinterlace filter.
	rawParams=$(${ffprobe} -v error -i "${inputFile}" -select_streams v:0 -show_entries streams)
	interlaced=$(echo ${rawParams} | grep -o 'field_order=[a-z]\+' | awk -F '=' '{print $2}' | head -1)
	videoLanguageTag=$(echo ${rawParams} | grep -o '')
	frameRateNum=$(echo ${rawParams} | grep -o 'r_frame_rate=[0-9]*/[0-9]\+' | awk -F '=' '{print $2}' | awk -F '/' '{print $1}' | head -1 | bc)
	frameRateDenom=$(echo ${rawParams} | grep -o 'r_frame_rate=[0-9]*/[0-9]\+' | awk -F '=' '{print $2}' | awk -F '/' '{print $2}' | head -1 | bc)
	frameRate="${frameRateNum}/${frameRateDenom}"
	numOfFrames=$(echo -e "${rawParams}" | egrep 'NUMBER_OF_FRAMES|nb_frames' | grep -v "N\/A" | grep "=" | awk -F '=' '{print $2}' | head -1)
	inputBitDepth=$(echo ${rawParams} | grep -o 'pix_fmt=[a-z,0-9]\+' | awk -F '=' '{print $2}' | head -1)
	sar=$(echo ${rawParams} | grep -o 'sample_aspect_ratio=[0-9]*:[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	dar=$(echo ${rawParams} | grep -o 'display_aspect_ratio=[0-9]*:[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	width=$(echo ${rawParams} | grep -o 'width=[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	height=$(echo ${rawParams} | grep -o 'height=[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	duration=$(echo ${rawParams} | grep -o 'duration=[0-9]\+' | awk -F '=' '{print $2}' | head -1)
	setDetelecine=0
	setSar=0
	setScale=0
	setFramerate=0
	setProgInInterlaced=0

	# Checks for various interface types.  Uses QSV "advanced" de-interlace option if interlaced.
	case ${interlaced} in
	        tt) setDeinterlace=1;;
	        bb) setDeinterlace=1;;
	        tb) setDeinterlace=1;;
	        bt) setDeinterlace=1;;
	        *) setDeinterlace=0;;
	esac

	# ffmpeg to detect black bars for cropping.
	rawCrop1=$(${ffmpeg} -ss 0 -t 10 -i "${inputFile}" -vf fps=1/2,cropdetect=mode=black:reset=50,metadata=mode=print -f null - 2>&1 | awk '/crop=/ {a=$NF} END{print a}' | awk -F '=' '{print $2}')
	rawCrop2=$(${ffmpeg} -ss 300 -t 10 -i "${inputFile}" -vf fps=1/2,cropdetect=mode=black:reset=50,metadata=mode=print -f null - 2>&1 | awk '/crop=/ {a=$NF} END{print a}' | awk -F '=' '{print $2}')
	rawCrop3=$(${ffmpeg} -ss 1800 -t 10 -i "${inputFile}" -vf fps=1/2,cropdetect=mode=black:reset=50,metadata=mode=print -f null - 2>&1 | awk '/crop=/ {a=$NF} END{print a}' | awk -F '=' '{print $2}')

	IFS=$'\n'
	w1=$(echo ${rawCrop1} | awk -F ":" '{print $1}')
	w2=$(echo ${rawCrop2} | awk -F ":" '{print $1}')
	w3=$(echo ${rawCrop3} | awk -F ":" '{print $1}')
	wSort=(${w1#-} ${w2#-} ${w3#-})
	w=$(echo "${wSort[*]}" | sort -nr | head -n1)

	h1=$(echo ${rawCrop1} | awk -F ":" '{print $2}')
	h2=$(echo ${rawCrop2} | awk -F ":" '{print $2}')
	h3=$(echo ${rawCrop3} | awk -F ":" '{print $2}')
        hSort=(${h1#-} ${h2#-} ${h3#-})
        h=$(echo "${hSort[*]}" | sort -nr | head -n1)

	x1=$(echo ${rawCrop1} | awk -F ":" '{print $3}')
	x2=$(echo ${rawCrop2} | awk -F ":" '{print $3}')
	x3=$(echo ${rawCrop3} | awk -F ":" '{print $3}')
        xSort=(${x1#-} ${x2#-} ${x3#-})
        x=$(echo "${xSort[*]}" | sort -n | head -n1)

	y1=$(echo ${rawCrop1} | awk -F ":" '{print $4}')
	y2=$(echo ${rawCrop2} | awk -F ":" '{print $4}')
	y3=$(echo ${rawCrop3} | awk -F ":" '{print $4}')
        ySort=(${y1#-} ${y2#-} ${y3#-})
        y=$(echo "${ySort[*]}" | sort -n | head -n1)

	IFS=$' \t\n'

	echo "Crop detection results: w=${w} h=${h} x=${x} y=${y}"

	inputFormat=""

	if [[ "${inputBitDepth}" == *"p10le"* ]] || [[ "${inputBitDepth}" == *"p12le"* ]]; then
		echo "Detected 10/12bit source.  Setting to p0101e"
		inputFormat="p010le"
	else
		echo "Detected 8bit source.  Setting to nv12"
		inputFormat="nv12"
	fi

        # If SAR is not 1:1, will set to 1:1 and dynamically scale the video accordingly.
        echo "Automatically detecting SAR/DAR"
        if [[ "${sar}" != "1:1" ]] && [ ! -z ${sar} ]; then
                setSar=1
                sarNum=$(echo ${sar} | awk -F ':' '{print $1}')
                sarDenom=$(echo ${sar} | awk -F ':' '{print $2}')
                sarRatio=$(awk "BEGIN {print ${sarNum} / ${sarDenom}}")
                darNum=$(echo ${dar} | awk -F ':' '{print $1}')
                darDenom=$(echo ${dar} | awk -F ':' '{print $2}')
                darRatio=$(awk "BEGIN {print ${darNum} / ${darDenom}}")
                darRatioWS=$(awk "BEGIN {print 16 /9}")
                darRatioDiff=$(awk "BEGIN {print ${darRatio} - ${darRatioWS}}")
                darRatioDiff=${darRatioDiff#-}
                ratio=$(awk "BEGIN {print ${darRatio} * ${sarRatio}}")
                ratioDiff=$(awk "BEGIN {print ${ratio} - 1.333}")
                ratioDiff=${ratioDiff#-}
                if [[ $(awk "BEGIN{print (${ratioDiff} < 0.2)}") -eq 1 ]]; then
                        echo "Altering dimensions to fix aspect ratio to ~4/3"
                        h_scale=${h}
                        w_scale=$(printf "%.0f" `awk "BEGIN {print ${height} * 1.333}"`)
			if [ ${w_scale} -ne ${width} ]; then
				setScale=1
			fi
                # Edge case.  Sometimes DAR is set to 16:9 and dynamically calculating via SAR/DAR results in extra wide, stretched, video.
                elif [[ $(awk "BEGIN{print (${ratioDiff} > 0.2)}") -eq 1 ]] && [[ $(awk "BEGIN{print (${darRatioDiff} < 0.05)}") -eq 1 ]]; then
                        echo "Altering dimension to fix aspect ratio to ~16/9"
                        w_scale=${w}
                        h_scale=$(printf "%.0f" `awk "BEGIN {print ${width} / 1.777777778}"`)
			if [ ${h_scale} -ne ${height} ]; then
                        	setScale=1
			fi
                else
                        echo "Altering dimensions to fix aspect ratio, widescreen"
                        setScale=1
                        w_scale=${w}
                        h_scale=$(printf "%.0f" `awk "BEGIN {print ${width} / ${ratio}}"`)
			if [ ${h_scale} -ne ${height} ]; then
                        	setScale=1
			fi
                fi
        elif [ -z ${sar} ]; then
                echo "SAR not set.  Setting to 1:1"
                setSar=1
                w_scale=${w}
                h_scale=${h}
        fi

	if [ ${setDeinterlace} -eq 1 ] || [ ${FORCEDETELECINE} -ne 0 ]; then
		if [ ${FORCEDETELECINE} -eq 0 ]; then
			echo "Detected interlaced video, checking for telecine"
			if [ "${numOfFrames}" == "" ]; then
				readFrames=3600
			elif [ ${numOfFrames} -lt 3600 ]; then
				readFrames=${numOfFrames}
			else
				readFrames=3600
			fi
			rawIdet=$(${ffmpeg} -filter:v idet -frames:v ${readFrames} -an -f rawvideo -y /dev/null -i "${inputFile}" 2>&1 | egrep "Repeated Fields|frame detection" | tail -3)
			idetProg1=$(echo $rawIdet | grep "Single frame detection" | tail -1 | grep -o 'Progressive: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetProg2=$(echo $rawIdet | grep "Multi frame detection" | tail -1 | grep -o 'Progressive: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetTFF1=$(echo $rawIdet | grep "Single frame detection" | tail -1 | grep -o 'TFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetTFF2=$(echo $rawIdet | grep "Multi frame detection" | tail -1 | grep -o 'TFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetBFF1=$(echo $rawIdet | grep "Single frame detection" | tail -1 | grep -o 'BFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetBFF2=$(echo $rawIdet | grep "Multi frame detection" | tail -1 | grep -o 'BFF: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetUndet1=$(echo $rawIdet | grep "Single frame detection" | tail -1 | grep -o 'Undetermined: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetUndet2=$(echo $rawIdet | grep "Multi frame detection" | tail -1 | grep -o 'Undetermined: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetRepeat1=$(echo $rawIdet | grep "Repeated Fields" | tail -1 | grep -o 'Neither: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetRepeat2=$(echo $rawIdet | grep "Repeated Fields" | tail -1 | grep -o 'Top: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			idetRepeat3=$(echo $rawIdet | grep "Repeated Fields" | tail -1 | grep -o 'Bottom: .*[0-9] \+' | awk -F ':' '{print $2}' | awk '{print $1}' | sed 's/ //g')
			progRatio1=$(printf "%.0f" `awk "BEGIN {print ( ${idetProg1} / ${readFrames} ) * 100}"`)
			progRatio2=$(printf "%.0f" `awk "BEGIN {print ( ${idetProg2} / ${readFrames} ) * 100}"`)
			TFFRatio1=$(printf "%.0f" `awk "BEGIN {print ( ${idetTFF1} / ${readFrames} ) * 100}"`)
			TFFRatio2=$(printf "%.0f" `awk "BEGIN {print ( ${idetTFF2} / ${readFrames} ) * 100}"`)
			BFFRatio1=$(printf "%.0f" `awk "BEGIN {print ( ${idetBFF1} / ${readFrames} ) * 100}"`)
			BFFRatio2=$(printf "%.0f" `awk "BEGIN {print ( ${idetBFF2} / ${readFrames} ) * 100}"`)
			unDetRatio1=$(printf "%.0f" `awk "BEGIN {print ( ${idetUndet1} / ${readFrames} ) * 100}"`)
			unDetRatio2=$(printf "%.0f" `awk "BEGIN {print ( ${idetUndet2} / ${readFrames} ) * 100}"`)
			repeatRatioNeither=$(printf "%.0f" `awk "BEGIN {print ( ${idetRepeat1} / ${readFrames} ) * 100}"`)
			repeatRatioTop=$(printf "%.0f" `awk "BEGIN {print ( ${idetRepeat2} / ${readFrames} ) * 100}"`)
			repeatRatioBottom=$(printf "%.0f" `awk "BEGIN {print ( ${idetRepeat3} / ${readFrames} ) * 100}"`)
			IFS=$'\n'
			progSort=(${progRatio1} ${progRatio2})
			TFFSort=(${TFFRatio1} ${TFFRatio2})
			BFFSort=(${BFFRatio1} ${BFFRatio2})
			unDetSort=(${unDetRatio1} ${unDetRatio2})
			largestProg=$(echo "${progSort[*]}" | sort -nr | head -n1)
			largestTFF=$(echo "${TFFSort[*]}" | sort -nr | head -n1)
			largestBFF=$(echo "${BFFSort[*]}" | sort -nr | head -n1)
			largestUnDet=$(echo "${unDetSort[*]}" | sort -nr | head -n1)
			IFS=$' \t\n'
			repeatRatioSum=$(awk "BEGIN { print ( ${repeatRatioTop} + ${repeatRatioBottom} )}")
			TFFRatio=$(awk "BEGIN { print ( ${largestTFF} + ${largestUnDet} )}")
			BFFRatio=$(awk "BEGIN { print ( ${largestBFF} + ${largestUnDet} )}")
		else
			echo "Forcing de-telecine"
			largestProg=0
			repeatRatioNeither=0
			TFFRatio=0
			BFFRatio=0
			repeatRatioSum=0
		fi

		if [ ${largestProg} -ge 5 ] || [ ${FORCEDETELECINE} -ne 0 ]; then
			setHWDL=1
			setHWUL=1
			setInFormat=1
			if [[ ( ${largestProg} -ge 30   &&  ${repeatRatioNeither} -ge 50 ) || ( ${FORCEDETELECINE} -eq 3 && ${FORCEDETELECINE} -ne 2 && ${FORCEDETELECINE} -ne 1 ) ]]; then
                                echo "Progressive video with interlaced encoding detected"
				echo "Will split fields and rejoin as progressive during encoding"
				setProgInInterlaced=1
                                FRAMERATE="-fps_mode passthrough"
                                setDeinterlace="0"
			elif [[ (( ${TFFRatio} -ge 30 || ${BFFRatio} -ge 30 ) && ${repeatRatioSum} -le ${repeatRatioNeither} ) || ( ${FORCEDETELECINE} -eq 1 && ${FORCEDETELECINE} -ne 2 && ${FORCEDETELECINE} -ne 3 ) ]]; then
				echo "Telecine detected, likely 24fps/48fps in 30fps/60fps"
				setDetelecine=1
				setFramerate=1
				newFrameRateNum=$(awk "BEGIN {print ${frameRateNum} * 0.8}")
				newFrameRate="${newFrameRateNum}/${frameRateDenom}"
				FRAMERATE=""
			elif [[ (( ${TFFRatio} -ge 20 || ${BFFRatio} -ge 20 ) && ${repeatRatioSum} -ge ${repeatRatioNeither} ) || ( ${FORCEDETELECINE} -eq 2 && ${FORCEDETELECINE} -ne 1 && ${FORCEDETELECINE} -ne 3 ) ]]; then
                                echo "Telecine detected, likely 24fps in 60fps"
                                setDetelecine=1
				setFramerate=1
                                newFrameRateNum=$(awk "BEGIN {print ${frameRateNum} * 0.4}")
				newFrameRate="${newFrameRateNum}/${frameRateDenom}"
                                FRAMERATE=""
			else
				echo "Telecine likely, but did not meet thresholds"
				EXITCODE=-2
				checkExitCode "Uncertain telecine detection"
			fi
		else
			echo "Telecine was not detected"
			FRAMERATE="-fps_mode passthrough"

		fi
	else
		echo "Detected progressive video"
		setHWDL=0
		FRAMERATE="-fps_mode passthrough"
	fi

	FILTERS=$(generateFilters)

	echo "Video filter result: ${FILTERS}" 1>&2

}

convertEIA608 () {
	eiaTracks=$(${ffprobe} -i "${INPUTFILE}" -select_streams s -show_entries stream -v quiet -of json | jq -r '.streams[] | select(.codec_name == ("eia_608")) | .index')
	otherSubTracks=$(${ffprobe} -i "${INPUTFILE}" -select_streams s -show_entries stream -v quiet -of json | jq -r '.streams[] | select(.codec_name != ("eia_608")) | .index')
	srtMKVFile=$(echo ${INPUTFILE} | awk -F '/' '{print $NF}' | sed "s/.${ext}/-subs.mkv/g")
	mapEIATracks=$(for index in ${eiaTracks}; do
		echo "-map 0:${index}"
	done)
	${ffmpeg} -v error -stats -y -i "${INPUTFILE}" -vn -an ${mapEIATracks} -c:s srt "${WIP}/${srtMKVFile}" < /dev/null
        EXITCODE=$?
        echo "$EXITCODE"
	mapSubTracks=$(if [ -z ${otherSubTracks} ]; then
			echo "-map 1:s"
		else
			for index in ${otherSubTracks}; do
				echo "-map 0:${index}"
			done
			echo "-map 1:s"
		fi)
	${ffmpeg} -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -i "${WIP}/${srtMKVFile}" -codec copy -map_chapters 0 -map 0:v -map 0:a? ${mapSubTracks} -map 0:t? "${remuxOutputFile}" < /dev/null
        EXITCODE=$?
        echo "$EXITCODE"
	rm -f "${WIP}/${srtMKVFile}"
}

# Checks if end time for last chapter is after the video's duration
checkChapters () {
	inputFileCheck=$1
	LENGTH=$(${ffprobe} -loglevel error -i "${inputFileCheck}" -print_format json -show_entries format=duration | grep duration | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | bc)
	LASTCHAPTEREND=$(${ffprobe} -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | grep end_time | tail -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	LASTCHAPTERSTART=$(${ffprobe} -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | grep start_time | tail -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	CHAPTERCOUNT=$(${ffprobe} -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | jq -r ' .[].[].id' | wc -l)
	SECONDLASTCHAPTERENDINDEX=$(awk "BEGIN {print ${CHAPTERCOUNT} - 1}" | bc)
	SECONDLASTCHAPTEREND=$(${ffprobe} -loglevel error -i "${inputFileCheck}" -print_format json -show_chapters | jq -r --arg l ${SECONDLASTCHAPTERENDINDEX} '[.chapters[]].[$l|fromjson]' | grep end_time | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)

	if [ -z ${LASTCHAPTEREND} ]; then
	        echo "${INPUTFILE} - No chapters present" 1>&2 | tee /dev/tty /dev/stderr
		echo "0"
	elif [ ${LASTCHAPTEREND} -gt ${LENGTH} ]; then
	        echo "Fixing bad last chapter for ${INPUTFILE}" 1>&2 | tee /dev/tty /dev/stderr
		echo "2"
	elif [ ! -z ${LASTCHAPTEREND} ] && [ ${SECONDLASTCHAPTEREND} -eq ${LASTCHAPTERSTART} ] && [ ${SECONDLASTCHAPTEREND} -eq ${LASTCHAPTEREND} ]; then
        	echo "${INPUTFILE} - Last chapter has no length.  Removing..." 1>&2 | tee /dev/tty /dev/stderr
		echo "3"
	else
	        echo "${INPUTFILE} - All chapters valid" 1>&2 | tee /dev/tty /dev/stderr
		echo "1"
	fi
}

repairChapters () {
	inputFileRepair=$1
	outputFileRepair=$2
	CHAPTERS=${WIP}/chapters.txt
	NEWCHAPTERS=${WIP}/newChapters.txt
	LASTCHAPTER=$(${ffprobe} -loglevel error -i "${inputFileRepair}" -print_format json -show_chapters | grep end_time | tail -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	TIMEBASE=$(${ffprobe} -loglevel error -i "${inputFileRepair}" -print_format json -show_chapters | grep time_base | head -1 | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | sed 's/\,//g' | bc)
	LENGTHMS=$(${ffprobe} -loglevel error -i "${inputFileRepair}" -print_format json -show_entries format=duration | grep duration | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | bc)

	${ffmpeg} -v error -y -i "${inputFileRepair}" -f ffmetadata ${CHAPTERS} < /dev/null
	lastEnd=$(cat ${CHAPTERS} | grep "END=" | tail -1 | awk -F '=' '{print $2}')
	lastStart=$(cat ${CHAPTERS} | grep "START=" | tail -1 | awk -F '=' '{print $2}')
	LENGTHMS=$(awk "BEGIN {print ${LENGTHMS} * 1000}" | bc)
	sed -i "s/${lastEnd}/${LENGTHMS}/g" ${CHAPTERS}
	lastEndNew=$(cat ${CHAPTERS} | grep "END=" | tail -1 | awk -F '=' '{print $2}')
	if [ ${lastEndNew} -le ${lastStart} ]; then
			BADCHAPTER=3
	fi
	if [ ${BADCHAPTER} -eq 2 ]; then
		${ffmpeg} -v error -y -stats -fflags +genpts+igndts -i "${inputFileRepair}" -f ffmetadata -i ${CHAPTERS} -map 0 -codec copy -map_metadata 1 -map_chapters 1 -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${outputFileRepair}" < /dev/null
		rm $CHAPTERS
	elif [ ${BADCHAPTER} -eq 3 ]; then
	        ${ffmpeg} -v error -y -i "${inputFileRepair}" -f ffmetadata ${CHAPTERS} < /dev/null
	        cat ${CHAPTERS} | head -n -5 > ${NEWCHAPTERS}
	        ${ffmpeg} -v error -y -stats -fflags +genpts+igndts -i "${inputFileRepair}" -f ffmetadata -i ${NEWCHAPTERS} -map 0 -codec copy -map_metadata 1 -map_chapters 1 -max_muxing_queue_size 2048 -max_interleave_delta 0 -avoid_negative_ts disabled "${outputFileRepair}" < /dev/null
		rm $CHAPTERS $NEWCHAPTERS
	else
		rm $CHAPTERS
	fi
	EXITCODE=$?
	checkExitCode "repairChapters"
}

fixSubtitlesTimestamps () {
	LENGTH=$(${ffprobe} -loglevel error -i "${inputFileCheck}" -print_format json -show_entries format=duration | grep duration | awk -F ': ' '{print $2}' | sed 's/\"//g' | sed 's/\.//g' | bc)
	${ffmpeg} -v error -stats -i "${remuxOutputFile}" -vn -an -map 0:s:${index} -f ass "${WIP}/${index}.ass"
	lastTimestamp=$(egrep "Dialogue|Comment|Picture|Sound|Movie|Command" "${WIP}/${index}.ass")
}

initialRemux () {
echo "Remuxing file to re-order tracks"
if [[ "${ext}" == "avi" ]] || [[ "${ext}" == "mpg" ]] || [[ "${ext}" == "mp4" ]] || [[ "${ext}" == "m2ts" ]] || [ "${NOEIA608}" = 'false' ]; then
        if [ "${NOMOVTEXT}" = 'false' ] && [ "${NOMSMPEG}" = 'true' ]; then
                echo "Remuxing to MP4"
                newExt="mp4"
                remuxOutputFile=$(echo ${SCRATCHDIR}/${shortFileName} | sed "s/.${ext}/-remux.${newExt}/g")
                if [ ${BADCHAPTER} -gt 1 ]; then
                        repairChapters "${INPUTFILE}" "${remuxOutputFile}"
                else
                        ${ffmpeg} -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_metadata 0 -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}" < /dev/null
                fi
        elif [ "${NOEIA608}" = 'false' ]; then
                echo "Remuxing to MKV and converting EIA608 subs"
                newExt="mkv"
                remuxOutputFile=$(echo ${SCRATCHDIR}/${shortFileName} | sed "s/.${ext}/-remux.${newExt}/g")
                if [ ${BADCHAPTER} -gt 1 ]; then
                        repairChapters "${INPUTFILE}" "${remuxOutputFile}"
                        convertEIA608
                else
                        convertEIA608
                fi
        elif [[ "${ext}" == "m2ts" ]]; then
                echo "Remuxing to M2TS"
                newExt="m2ts"
                remuxOutputFile=$(echo ${SCRATCHDIR}/${shortFileName} | sed "s/.${ext}/-remux.${newExt}/g")
                if [ ${BADCHAPTER} -gt 1 ]; then
                        repairChapters "${INPUTFILE}" "${remuxOutputFile}"
                else
                        ${ffmpeg} -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_metadata 0 -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}" < /dev/null
                fi
        else
                echo "Remuxing to MKV"
                newExt="mkv"
                remuxOutputFile=$(echo ${SCRATCHDIR}/${shortFileName} | sed "s/.${ext}/-remux.${newExt}/g")
                if [ ${BADCHAPTER} -gt 1 ]; then
                        repairChapters "${INPUTFILE}" "${remuxOutputFile}"
                else
                        ${ffmpeg} -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_metadata 0 -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}" < /dev/null
                fi
        fi
else
        echo "Remuxing to MKV"
        newExt="mkv"
        remuxOutputFile=$(echo ${SCRATCHDIR}/${shortFileName} | sed "s/.${ext}/-remux.${newExt}/g")
        if [ ${BADCHAPTER} -gt 1 ]; then
                repairChapters "${INPUTFILE}" "${remuxOutputFile}"
        else
                ${ffmpeg} -v error -stats -fflags +genpts+igndts -y -i "${INPUTFILE}" -codec copy -map_metadata 0 -map_chapters 0 -map 0:v? -map 0:a? -map 0:s? -map 0:t? "${remuxOutputFile}" < /dev/null
        fi
fi

EXITCODE=$?
checkExitCode "initialRemux"
}

# Remuxes input file so that video tracks are grouped first, audio second, subs, third.  Simplifies track selection logic
# and resolves issues where weirdly ordered input files cause improper track selection.
ext=$(echo ${INPUTFILE} | awk -F '.' '{print $NF}')
remuxOutputFile=""
newExt=""

SUBFFPROBE=$(${ffprobe} -i "${INPUTFILE}" -select_streams s -show_entries stream -v quiet -of json)
NOMOVTEXT=$(jq '[.streams[] | select(.codec_name == ("mov_text"))]' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
NOEIA608=$(jq '[.streams[] | select(.codec_name == ("eia_608"))]' <<< ${SUBFFPROBE} | jq -e '. | length == 0')
NOMSMPEG=$(${ffprobe} -i "${INPUTFILE}" -select_streams v -show_entries stream -v quiet -of json | jq '[.streams[] | select(.codec_name == ("msmpeg4v3"))] | length == 0')
shortFileName=$(echo $INPUTFILE | awk -F '/' '{print $NF}')

# Checks if end time for last chapter is after the video's duration
BADCHAPTER=$(checkChapters "${INPUTFILE}")

# Reorders tracks to account for weirdly ordered files.  Makes audio/sub selection more consistent.
initialRemux

# Get ffprobe info to be used by other functions.
AUDIOFFPROBE=$(${ffprobe} -i "${remuxOutputFile}" -select_streams a -show_entries stream -v quiet -of json)
AV1PROBE=$(${ffprobe} -i "${remuxOutputFile}" -select_streams v -show_entries stream -v quiet -of json | jq '[.streams[] | select(.codec_name == ("av1"))]')
SUBFFPROBE=$(${ffprobe} -i "${remuxOutputFile}" -select_streams s -show_entries stream -v quiet -of json)
ATTACHMENTFFPROBE=$(${ffprobe} -v error -i "${remuxOutputFile}" -select_streams t -show_entries stream=index -show_entries stream_tags=filename -of json)
EMPTYAUDIOJSON=$(jq '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("jpn"))]' <<< "${AUDIOFFPROBE}" | jq -e '. | length == 0')

# Checks for subtitle track or untagged subtitle tracks.
EMPTYSUBJSON=$(jq -e '.streams | length == 0' <<< "${SUBFFPROBE}")
UNTAGGEDSUBJSON=$(jq '[.streams[] | select(.tags.language)]' <<< "${SUBFFPROBE}" | jq -e '. | length == 0')

# Checks for attachments
EMPTYATTACHMENTJSON=$(jq -e '.streams | length == 0' <<< "${ATTACHMENTFFPROBE}")

SWDECODE=$(${ffprobe} -i "${remuxOutputFile}" -select_streams v -show_entries stream -v quiet -of json | jq '[.streams[] | select(.profile == ("High 10") or .profile == ("Advanced Simple Profile") or .codec_name == ("mpeg1video") or .codec_name == ("vp8") or .codec_name == ("vc1") or .codec_name == ("msmpeg4v3") or .codec_name == ("mpeg4") or .profile == ("High 4:2:2") or .profile == ("High 4:4:4 Predictive") or .codec_name == ("wmv2") or .codec_name == ("wmv3"))] | length != 0')

if [[ "${SWDECODE}" == "true" ]]; then
	echo "Disabling hardware accelerated decoding"
        decodeAccel=""
	setHWUL=1
	setInFormat=1
        setHWDL=0
elif [[ "${NOHWADECODE}" == "1" ]]; then
	echo "Manually disabled hardware accelerated decoding"
        decodeAccel=""
	setHWUL=1
	setInFormat=1
        setHWDL=0
else
	echo "Using hardware accelerated decoding"
        decodeAccel="-hwaccel qsv"
        setHWDL=0
	setHWUL=0
	setInFormat=0
fi

audioLanguages="eng"

foreignAudio=""
if [ ${ANIME} -eq 1 ]; then
	foreignAudio="jpn"
	audioLanguages+=" jpn"
	echo "Selecting English and Japanese audio/subtitle tracks."
elif [ ${KOREAN} -eq 1 ]; then
	foreignAudio="kor"
	audioLanguages+=" kor"
	echo "Selecting English and Korean audio/subtitle tracks."
elif [ ${CHINESE} -eq 1 ]; then
	foreignAudio="chi"
	audioLanguages+=" chi"
	audioLanguages+=" zho"
	echo "Selecting English and Chinese audio/subtitle tracks."
elif [ ${SPANISH} -eq 1 ]; then
	foreignAudio="spa"
	audioLanguages+=" spa"
	echo "Selecting English and Chinese audio/subtitle tracks."
else
	echo "Selecting English audio/subtitle tracks."
fi

if [ ${ANIME} -ne 0 ] || [ ${KOREAN} -ne 0 ] || [ ${CHINESE} -ne 0 ]; then
	SELECTEDAUDIO=$(jq -r --arg langs ${foreignAudio} '[.streams[] | select(.tags.language == ("eng") or .tags.language == ($langs))]' <<< "${AUDIOFFPROBE}")
else
	SELECTEDAUDIO=$(jq -r '[.streams[] | select(.tags.language == ("eng"))]' <<< "${AUDIOFFPROBE}")
fi

if [ "${UNTAGGEDSUBJSON}" = 'true' ]; then
	if [ "${EMPTYSUBJSON}" = 'true' ]; then
		echo "No subtitle track"
	else
		SELECTEDSUBS=$(jq -r '[.streams[]]' <<< "${SUBFFPROBE}")
	fi
else
	SELECTEDSUBS=$(jq -r '[.streams[] | select(.tags.language == ("eng") or .tags.language == ("zxx") or .tags.language == ("enm"))]' <<< "${SUBFFPROBE}")
	EMPTYSELECTEDSUBJSON=$(jq -e '.[] | length == 0' <<< "${SELECTEDSUBS}")
	if [ "${EMPTYSELECTEDSUBJSON}" = 'true' ]; then
		# Have occasionally encountered media where the English track is labeled "jpn", possibly to appease aubtitle selection logic for a particular media player
		echo "No English subtitle tracks found.  Looking for mistagged \"Japanese\" tracks"
		SELECTEDSUBS=$(jq -r '[.streams[] | select(.tags.language == ("jpn"))]' <<< "${SUBFFPROBE}")
		EMPTYSELECTEDSUBJSON=$(jq -e '.[] | length == 0' <<< "${SELECTEDSUBS}")
		if [ "${EMPTYSELECTEDSUBJSON}" = 'true' ]; then
			SELECTEDSUBS=$(jq -r '[.streams[]]' <<< "${SUBFFPROBE}")
			echo "Did not find English.  Selecting all subtitles."
		else
			echo "Found \"English\" subtitles"
		fi
	fi
fi

audioCommand=$(audioMapping)
subCommand=$(subMapping)

# If the -c option is used to provide the number of chapters per episode, in instances where a rip has all episodes in one MKV, this will call
# the function.  Otherwise the entire file will be processed.
# If -s is used, it will loop through the segments provided to extract the episodes based on chapter numbers provided.
# The segments start and end are colon sepearate, episodes are comma separated.
if [ ! -z ${CHAPTERSEPISODE} ]; then
        chapterProbe=$(${ffprobe} -v error -i "${remuxOutputFile}" -print_format json -show_chapters)
        EMPTYCHAPTERPROBE=$(${ffprobe} -v error -i "${remuxOutputFile}" -print_format json -show_chapters | jq -r '.[] | length == 0')
        if [[ "${EMPTYCHAPTERPROBE}" != "true" ]]; then
                echo "Splitting file in ${CHAPTERSEPISODE} chapter segments"
                splitEpisodes ${CHAPTERSEPISODE}
        else
                echo "No chapters found.  Will not split file."
                CHAPTERFILES=$(echo "${remuxOutputFile}")
        fi
elif [ ! -z ${CHAPSELECT} ]; then
        chapterProbe=$(${ffprobe} -v error -i "${remuxOutputFile}" -print_format json -show_chapters)
        EMPTYCHAPTERPROBE=$(${ffprobe} -v error -i "${remuxOutputFile}" -print_format json -show_chapters | jq -r '.[] | length == 0')
        if [[ "${EMPTYCHAPTERPROBE}" != "true" ]]; then
                echo "Using user provided start/end chapters."
                segments=$(echo ${CHAPSELECT} | sed 's/,/ /g')
                for segment in ${segments} ; do
                        STARTCHAP=$(echo ${segment} | awk -F ':' '{print $1}')
                        ENDCHAP=$(echo ${segment} | awk -F ':' '{print $2}')
                        chapterSelect ${STARTCHAP} ${ENDCHAP}
                done
                CHAPTERFILES=$(find ${WIP} -type f | sort)
        else
                echo "No chapters found.  Will not split file."
                CHAPTERFILES=$(echo "${remuxOutputFile}")
        fi
else
        echo "Not splitting input file"
        CHAPTERFILES=$(echo "${remuxOutputFile}")
fi

OIFS="$IFS"
IFS=$'\n'
for file in ${CHAPTERFILES}; do
IFS="$OIFS"
	if [ ${ENGLISHSELECTION} -eq 1 ]; then
		echo "Remux + English audio/subtitle selection only"
		audioRemuxOnly "${file}"
	elif [ ${AUDIOCONVERSION} -eq 1 ] || [ "${AV1PROBE}" != "[]" ]; then
		if [ "${AV1PROBE}" != "[]" ]; then
			echo "Video codec is already AV1"
		fi
		echo "Converting audio only"
		audioRemuxOnly "${file}"
	else
		echo "Generating video filter parameters"
		generateFilterParameters "${file}"
		av1Encode "${file}"
	fi
IFS=$'\n'
done
IFS="$OIFS"

EXITCODE=-1
checkExitCode "END"